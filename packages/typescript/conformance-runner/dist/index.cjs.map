{"version":3,"sources":["../src/index.ts","../src/loader.ts","../src/client.ts","../src/runner.ts","../src/reporters/text.ts","../src/reporters/json.ts","../src/reporters/junit.ts"],"sourcesContent":["/**\n * @dotdo/conformance-runner\n *\n * Cross-language conformance test runner for DotDo RPC implementations.\n * This package can test any server implementation that speaks the DotDo\n * RPC protocol over WebSocket.\n *\n * CLI Usage:\n *   npx @dotdo/conformance-runner --server-url ws://localhost:8787\n *\n * Programmatic Usage:\n *   import { runConformanceTests, loadTestSpecs } from '@dotdo/conformance-runner';\n *\n *   const specs = loadTestSpecs('/path/to/conformance/tests');\n *   const results = await runConformanceTests(specs, {\n *     serverUrl: 'ws://localhost:8787',\n *     ...\n *   });\n */\n\n// Types\nexport type {\n  TestSpec,\n  TestCase,\n  TestResult,\n  SuiteResult,\n  RunResult,\n  RunnerOptions,\n  PipelineStep,\n  SetupStep,\n  SequenceStep,\n  MapSpec,\n  ExportSpec,\n  VerifyStep,\n  ErrorExpectation,\n} from './types.js';\n\n// Loader\nexport {\n  loadTestSpecs,\n  loadTestSpec,\n  filterBySuites,\n  filterByPattern,\n  getSpecsSummary,\n} from './loader.js';\n\n// Runner\nexport { runConformanceTests } from './runner.js';\n\n// Client\nexport { ConformanceClient, type CapabilityRef } from './client.js';\n\n// Reporters\nexport { formatTextReport } from './reporters/text.js';\nexport { formatJsonReport } from './reporters/json.js';\nexport { formatJUnitReport } from './reporters/junit.js';\n","/**\n * YAML test specification loader\n * Loads and validates conformance test files\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as yaml from 'js-yaml';\nimport type { TestSpec } from './types.js';\n\n/**\n * Load all YAML test specifications from a directory\n */\nexport function loadTestSpecs(testPath: string): TestSpec[] {\n  const specs: TestSpec[] = [];\n\n  if (!fs.existsSync(testPath)) {\n    throw new Error(`Test path does not exist: ${testPath}`);\n  }\n\n  const stat = fs.statSync(testPath);\n\n  if (stat.isFile()) {\n    // Single file\n    if (testPath.endsWith('.yaml') || testPath.endsWith('.yml')) {\n      specs.push(loadTestSpec(testPath));\n    } else {\n      throw new Error(`Test file must be a YAML file: ${testPath}`);\n    }\n  } else if (stat.isDirectory()) {\n    // Directory - load all YAML files\n    const files = fs.readdirSync(testPath)\n      .filter(f => f.endsWith('.yaml') || f.endsWith('.yml'))\n      .sort();\n\n    for (const file of files) {\n      const filePath = path.join(testPath, file);\n      specs.push(loadTestSpec(filePath));\n    }\n  } else {\n    throw new Error(`Invalid test path: ${testPath}`);\n  }\n\n  return specs;\n}\n\n/**\n * Load a single YAML test specification file\n */\nexport function loadTestSpec(filePath: string): TestSpec {\n  const content = fs.readFileSync(filePath, 'utf-8');\n  const spec = yaml.load(content) as TestSpec;\n\n  // Validate the spec\n  validateTestSpec(spec, filePath);\n\n  return spec;\n}\n\n/**\n * Validate a test specification\n */\nfunction validateTestSpec(spec: TestSpec, filePath: string): void {\n  if (!spec.name) {\n    throw new Error(`Test spec missing 'name' field in ${filePath}`);\n  }\n\n  if (!spec.tests || !Array.isArray(spec.tests)) {\n    throw new Error(`Test spec missing 'tests' array in ${filePath}`);\n  }\n\n  for (const test of spec.tests) {\n    if (!test.name) {\n      throw new Error(`Test case missing 'name' field in ${filePath}`);\n    }\n\n    // Validate that the test has at least one action\n    const hasAction = test.call || test.pipeline || test.sequence;\n    if (!hasAction && !test.export) {\n      throw new Error(\n        `Test case '${test.name}' must have at least one of: call, pipeline, sequence, export in ${filePath}`\n      );\n    }\n  }\n}\n\n/**\n * Filter test specs by suite names\n */\nexport function filterBySuites(specs: TestSpec[], suiteNames: string[]): TestSpec[] {\n  if (!suiteNames.length) {\n    return specs;\n  }\n\n  const lowerNames = suiteNames.map(n => n.toLowerCase());\n  return specs.filter(spec =>\n    lowerNames.some(name =>\n      spec.name.toLowerCase().includes(name) ||\n      spec.name.toLowerCase().replace(/\\s+/g, '-').includes(name) ||\n      spec.name.toLowerCase().replace(/\\s+/g, '_').includes(name)\n    )\n  );\n}\n\n/**\n * Filter tests within specs by name pattern\n */\nexport function filterByPattern(specs: TestSpec[], pattern: string): TestSpec[] {\n  const regex = new RegExp(pattern, 'i');\n\n  return specs\n    .map(spec => ({\n      ...spec,\n      tests: spec.tests.filter(test =>\n        regex.test(test.name) || (test.description && regex.test(test.description))\n      ),\n    }))\n    .filter(spec => spec.tests.length > 0);\n}\n\n/**\n * Get a summary of loaded test specs\n */\nexport function getSpecsSummary(specs: TestSpec[]): {\n  totalSuites: number;\n  totalTests: number;\n  suites: Array<{ name: string; testCount: number }>;\n} {\n  return {\n    totalSuites: specs.length,\n    totalTests: specs.reduce((sum, spec) => sum + spec.tests.length, 0),\n    suites: specs.map(spec => ({\n      name: spec.name,\n      testCount: spec.tests.length,\n    })),\n  };\n}\n","/**\n * WebSocket RPC client for conformance testing\n * Connects to any language's server implementation\n */\n\nimport WebSocket from 'ws';\n\n/**\n * Message types for the RPC protocol\n */\ninterface RpcRequest {\n  id: number;\n  method: string;\n  target?: number;\n  args?: unknown[];\n}\n\ninterface RpcPipelineRequest {\n  id: number;\n  steps: Array<{\n    method: string;\n    target?: string | number;\n    args: unknown[];\n    as?: string;\n  }>;\n}\n\ninterface RpcResponse {\n  id: number;\n  result?: unknown;\n  error?: {\n    type: string;\n    message: string;\n  };\n}\n\ninterface RpcPipelineResponse {\n  id: number;\n  results?: Record<string, { result?: unknown; error?: { type: string; message: string } }>;\n  error?: {\n    type: string;\n    message: string;\n  };\n}\n\n/**\n * Capability reference (stub)\n */\nexport interface CapabilityRef {\n  __capabilityId: number;\n}\n\n/**\n * RPC client for conformance testing\n */\nexport class ConformanceClient {\n  private ws: WebSocket | null = null;\n  private requestId = 0;\n  private pendingRequests = new Map<\n    number,\n    {\n      resolve: (value: unknown) => void;\n      reject: (error: Error) => void;\n    }\n  >();\n  private connected = false;\n  private capabilities = new Map<number, unknown>();\n  private roundTripCount = 0;\n\n  /**\n   * Connect to a WebSocket server\n   */\n  async connect(url: string, timeout = 10000): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        reject(new Error(`Connection timeout after ${timeout}ms`));\n      }, timeout);\n\n      try {\n        this.ws = new WebSocket(url);\n\n        this.ws.on('open', () => {\n          clearTimeout(timer);\n          this.connected = true;\n          resolve();\n        });\n\n        this.ws.on('message', (data: Buffer | string) => {\n          this.handleMessage(data.toString());\n        });\n\n        this.ws.on('error', (error) => {\n          clearTimeout(timer);\n          this.connected = false;\n          reject(error);\n        });\n\n        this.ws.on('close', () => {\n          this.connected = false;\n          // Reject all pending requests\n          for (const [id, { reject }] of this.pendingRequests) {\n            reject(new Error('Connection closed'));\n            this.pendingRequests.delete(id);\n          }\n        });\n      } catch (error) {\n        clearTimeout(timer);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Disconnect from the server\n   */\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.connected = false;\n    this.pendingRequests.clear();\n    this.capabilities.clear();\n  }\n\n  /**\n   * Check if connected\n   */\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Get round trip count (for testing pipelining efficiency)\n   */\n  getRoundTripCount(): number {\n    return this.roundTripCount;\n  }\n\n  /**\n   * Reset round trip counter\n   */\n  resetRoundTrips(): void {\n    this.roundTripCount = 0;\n  }\n\n  /**\n   * Call a method on the root object\n   */\n  async call(method: string, ...args: unknown[]): Promise<unknown> {\n    return this.sendRequest({ method, args });\n  }\n\n  /**\n   * Call a method on a capability\n   */\n  async callOnCapability(\n    capability: CapabilityRef | unknown,\n    method: string,\n    ...args: unknown[]\n  ): Promise<unknown> {\n    const target = this.getCapabilityId(capability);\n    return this.sendRequest({ method, target, args });\n  }\n\n  /**\n   * Execute a pipeline of calls in a single round trip\n   */\n  async pipeline(\n    steps: Array<{\n      method: string;\n      target?: string | number | CapabilityRef;\n      args?: unknown[];\n      as?: string;\n    }>\n  ): Promise<Record<string, unknown>> {\n    const resolvedSteps = steps.map((step) => ({\n      method: step.method,\n      target: this.resolveTarget(step.target),\n      args: this.resolveArgs(step.args || []),\n      as: step.as,\n    }));\n\n    const id = ++this.requestId;\n    const request: RpcPipelineRequest = { id, steps: resolvedSteps };\n\n    return new Promise((resolve, reject) => {\n      this.pendingRequests.set(id, {\n        resolve: (response) => {\n          const pipelineResp = response as RpcPipelineResponse;\n          if (pipelineResp.error) {\n            const err = new Error(pipelineResp.error.message);\n            err.name = pipelineResp.error.type;\n            reject(err);\n          } else if (pipelineResp.results) {\n            // Process results and extract capabilities\n            const results: Record<string, unknown> = {};\n            for (const [key, value] of Object.entries(pipelineResp.results)) {\n              if (value.error) {\n                results[key] = { error: value.error };\n              } else {\n                results[key] = this.processResult(value.result);\n              }\n            }\n            resolve(results);\n          } else {\n            resolve({});\n          }\n        },\n        reject,\n      });\n\n      this.sendRaw(request);\n    });\n  }\n\n  /**\n   * Get self reference (capability ID 0)\n   */\n  getSelf(): CapabilityRef {\n    return { __capabilityId: 0 };\n  }\n\n  /**\n   * Check if a value is a capability reference\n   */\n  isCapabilityRef(value: unknown): value is CapabilityRef {\n    return (\n      typeof value === 'object' &&\n      value !== null &&\n      '__capabilityId' in value &&\n      typeof (value as CapabilityRef).__capabilityId === 'number'\n    );\n  }\n\n  private async sendRequest(request: Omit<RpcRequest, 'id'>): Promise<unknown> {\n    if (!this.connected || !this.ws) {\n      throw new Error('Not connected');\n    }\n\n    const id = ++this.requestId;\n    const fullRequest: RpcRequest = { id, ...request };\n\n    return new Promise((resolve, reject) => {\n      this.pendingRequests.set(id, {\n        resolve: (response) => {\n          const rpcResp = response as RpcResponse;\n          if (rpcResp.error) {\n            const err = new Error(rpcResp.error.message);\n            err.name = rpcResp.error.type;\n            reject(err);\n          } else {\n            resolve(this.processResult(rpcResp.result));\n          }\n        },\n        reject,\n      });\n\n      this.sendRaw(fullRequest);\n    });\n  }\n\n  private sendRaw(data: unknown): void {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket not open');\n    }\n\n    this.roundTripCount++;\n    this.ws.send(JSON.stringify(data));\n  }\n\n  private handleMessage(data: string): void {\n    try {\n      const message = JSON.parse(data);\n\n      // Handle response\n      if ('id' in message && this.pendingRequests.has(message.id)) {\n        const { resolve } = this.pendingRequests.get(message.id)!;\n        this.pendingRequests.delete(message.id);\n        resolve(message);\n      }\n    } catch (error) {\n      console.error('Failed to parse message:', error);\n    }\n  }\n\n  private processResult(result: unknown): unknown {\n    if (result === null || result === undefined) {\n      return result;\n    }\n\n    // Check for capability reference\n    if (typeof result === 'object' && '$ref' in (result as object)) {\n      const capId = (result as { $ref: number }).$ref;\n      const capRef: CapabilityRef = { __capabilityId: capId };\n      this.capabilities.set(capId, capRef);\n      return capRef;\n    }\n\n    // Process arrays\n    if (Array.isArray(result)) {\n      return result.map((item) => this.processResult(item));\n    }\n\n    // Process objects\n    if (typeof result === 'object') {\n      const processed: Record<string, unknown> = {};\n      for (const [key, value] of Object.entries(result)) {\n        processed[key] = this.processResult(value);\n      }\n      return processed;\n    }\n\n    return result;\n  }\n\n  private getCapabilityId(capability: unknown): number {\n    if (this.isCapabilityRef(capability)) {\n      return capability.__capabilityId;\n    }\n    throw new Error('Invalid capability reference');\n  }\n\n  private resolveTarget(target: string | number | CapabilityRef | undefined): string | number | undefined {\n    if (target === undefined) {\n      return undefined;\n    }\n    if (typeof target === 'string' || typeof target === 'number') {\n      return target;\n    }\n    if (this.isCapabilityRef(target)) {\n      return target.__capabilityId;\n    }\n    return undefined;\n  }\n\n  private resolveArgs(args: unknown[]): unknown[] {\n    return args.map((arg) => {\n      if (this.isCapabilityRef(arg)) {\n        return { $ref: arg.__capabilityId };\n      }\n      if (Array.isArray(arg)) {\n        return this.resolveArgs(arg);\n      }\n      if (typeof arg === 'object' && arg !== null) {\n        const resolved: Record<string, unknown> = {};\n        for (const [key, value] of Object.entries(arg)) {\n          resolved[key] = this.resolveArgs([value])[0];\n        }\n        return resolved;\n      }\n      return arg;\n    });\n  }\n}\n","/**\n * Test runner for conformance tests\n * Executes tests against any server implementation\n */\n\nimport type {\n  TestSpec,\n  TestCase,\n  TestResult,\n  SuiteResult,\n  RunResult,\n  RunnerOptions,\n  SetupStep,\n  SequenceStep,\n} from './types.js';\nimport { ConformanceClient, type CapabilityRef } from './client.js';\n\n/**\n * Run all conformance tests against a server\n */\nexport async function runConformanceTests(\n  specs: TestSpec[],\n  options: RunnerOptions\n): Promise<RunResult> {\n  const startTime = Date.now();\n  const suites: SuiteResult[] = [];\n\n  let totalPassed = 0;\n  let totalFailed = 0;\n  let totalSkipped = 0;\n\n  for (const spec of specs) {\n    const suiteResult = await runSuite(spec, options);\n    suites.push(suiteResult);\n\n    totalPassed += suiteResult.passed;\n    totalFailed += suiteResult.failed;\n    totalSkipped += suiteResult.skipped;\n\n    if (options.bail && suiteResult.failed > 0) {\n      break;\n    }\n  }\n\n  return {\n    suites,\n    totalPassed,\n    totalFailed,\n    totalSkipped,\n    totalDuration: Date.now() - startTime,\n    timestamp: new Date().toISOString(),\n    serverUrl: options.serverUrl,\n  };\n}\n\n/**\n * Run a single test suite\n */\nasync function runSuite(spec: TestSpec, options: RunnerOptions): Promise<SuiteResult> {\n  const startTime = Date.now();\n  const results: TestResult[] = [];\n\n  let passed = 0;\n  let failed = 0;\n  let skipped = 0;\n\n  for (const test of spec.tests) {\n    const result = await runTest(spec.name, test, options);\n    results.push(result);\n\n    switch (result.status) {\n      case 'passed':\n        passed++;\n        break;\n      case 'failed':\n        failed++;\n        break;\n      case 'skipped':\n        skipped++;\n        break;\n    }\n\n    if (options.bail && result.status === 'failed') {\n      // Mark remaining tests as skipped\n      for (const remaining of spec.tests.slice(spec.tests.indexOf(test) + 1)) {\n        results.push({\n          name: remaining.name,\n          suite: spec.name,\n          status: 'skipped',\n          duration: 0,\n          skipReason: 'Skipped due to bail on failure',\n        });\n        skipped++;\n      }\n      break;\n    }\n  }\n\n  return {\n    name: spec.name,\n    tests: results,\n    passed,\n    failed,\n    skipped,\n    duration: Date.now() - startTime,\n  };\n}\n\n/**\n * Run a single test case\n */\nasync function runTest(\n  suiteName: string,\n  test: TestCase,\n  options: RunnerOptions\n): Promise<TestResult> {\n  const startTime = Date.now();\n\n  // Create a new client for each test\n  const client = new ConformanceClient();\n  const context = new Map<string, unknown>();\n\n  try {\n    // Connect to the server\n    await client.connect(options.serverUrl, options.timeout);\n\n    // Execute the test\n    await executeTest(client, test, context);\n\n    // Test passed\n    client.disconnect();\n    return {\n      name: test.name,\n      suite: suiteName,\n      status: 'passed',\n      duration: Date.now() - startTime,\n    };\n  } catch (error) {\n    client.disconnect();\n\n    const err = error as Error;\n    return {\n      name: test.name,\n      suite: suiteName,\n      status: 'failed',\n      duration: Date.now() - startTime,\n      error: err.message,\n      stackTrace: err.stack,\n    };\n  }\n}\n\n/**\n * Execute a single test case\n */\nasync function executeTest(\n  client: ConformanceClient,\n  test: TestCase,\n  context: Map<string, unknown>\n): Promise<void> {\n  client.resetRoundTrips();\n\n  // Handle setup steps\n  if (test.setup) {\n    await executeSetup(client, test.setup, context);\n    client.resetRoundTrips(); // Reset after setup\n  }\n\n  // Handle exports (callbacks) - skip for now as this requires server support\n  if (test.export) {\n    // Callbacks require bidirectional communication which may not be supported\n    // For now, we note this as a limitation\n  }\n\n  // Handle pipeline tests\n  if (test.pipeline) {\n    await executePipeline(client, test, context);\n    return;\n  }\n\n  // Handle sequence tests\n  if (test.sequence) {\n    await executeSequence(client, test.sequence, context);\n    return;\n  }\n\n  // Handle map tests\n  if (test.map && test.call) {\n    // Map operations require special server support\n    // This is a simplified implementation\n    throw new Error('Map tests require server-side map support (not yet implemented in runner)');\n  }\n\n  // Simple call test\n  if (test.call) {\n    await executeSimpleCall(client, test, context);\n  }\n}\n\n/**\n * Execute setup steps\n */\nasync function executeSetup(\n  client: ConformanceClient,\n  setup: SetupStep[],\n  context: Map<string, unknown>\n): Promise<void> {\n  for (const step of setup) {\n    if (step.pipeline) {\n      // Execute pipeline in setup\n      const pipelineSteps = step.pipeline.map((ps) => ({\n        method: ps.call,\n        args: resolveArgs(ps.args || [], context, client),\n        as: ps.as,\n      }));\n\n      const results = await client.pipeline(pipelineSteps);\n\n      if (step.as) {\n        const lastStep = step.pipeline[step.pipeline.length - 1];\n        const key = lastStep.as || '__last';\n        context.set(step.as, results[key]);\n      }\n    } else {\n      const result = await executeCall(client, step.call, step.args || [], context);\n      if (step.as) {\n        context.set(step.as, result);\n      }\n    }\n  }\n}\n\n/**\n * Execute a pipeline test\n */\nasync function executePipeline(\n  client: ConformanceClient,\n  test: TestCase,\n  context: Map<string, unknown>\n): Promise<void> {\n  const pipeline = test.pipeline!;\n\n  // Collect all step names for reference resolution\n  const stepNames = new Set(pipeline.filter((s) => s.as).map((s) => s.as!));\n\n  // Build pipeline steps\n  const steps = pipeline.map((step) => {\n    const parts = step.call.split('.');\n    if (parts.length === 1) {\n      return {\n        method: step.call,\n        args: resolvePipelineArgs(step.args || [], context, stepNames, client),\n        as: step.as,\n      };\n    } else {\n      // Call on a pipelined result (e.g., counter.value)\n      const [targetName, ...methodParts] = parts;\n      return {\n        method: methodParts.join('.'),\n        target: targetName,\n        args: resolvePipelineArgs(step.args || [], context, stepNames, client),\n        as: step.as,\n      };\n    }\n  });\n\n  const results = await client.pipeline(steps);\n\n  // Check for errors if expect_error is set\n  if (test.expect_error) {\n    const lastKey = pipeline[pipeline.length - 1].as || '__last';\n    const lastResult = results[lastKey] as { error?: { type: string; message: string } };\n\n    if (lastResult?.error) {\n      // We got the expected error\n      if (test.expect_error.type && lastResult.error.type !== test.expect_error.type) {\n        throw new Error(\n          `Expected error type '${test.expect_error.type}' but got '${lastResult.error.type}'`\n        );\n      }\n      if (\n        test.expect_error.message_contains &&\n        !lastResult.error.message.includes(test.expect_error.message_contains)\n      ) {\n        throw new Error(\n          `Expected error message to contain '${test.expect_error.message_contains}' but got '${lastResult.error.message}'`\n        );\n      }\n      return; // Error expectation met\n    } else {\n      throw new Error('Expected pipeline to fail with error');\n    }\n  }\n\n  // Check expectations\n  if (test.expect !== undefined) {\n    if (typeof test.expect === 'object' && !Array.isArray(test.expect) && test.expect !== null) {\n      // Expect multiple named results\n      for (const [key, expectedValue] of Object.entries(test.expect as Record<string, unknown>)) {\n        const actualResult = results[key] as { error?: unknown };\n        if (actualResult?.error) {\n          throw new Error(`Step '${key}' failed with error`);\n        }\n        assertDeepEqual(actualResult, expectedValue, `Step '${key}'`);\n      }\n    } else {\n      // Expect the result of the last step\n      const lastStep = pipeline[pipeline.length - 1];\n      const lastKey = lastStep.as || '__last';\n      const lastResult = results[lastKey];\n      assertDeepEqual(lastResult, test.expect, 'Pipeline result');\n    }\n  }\n\n  // Check round trips\n  if (test.max_round_trips !== undefined) {\n    const roundTrips = client.getRoundTripCount();\n    if (roundTrips > test.max_round_trips) {\n      throw new Error(\n        `Expected at most ${test.max_round_trips} round trips but used ${roundTrips}`\n      );\n    }\n  }\n}\n\n/**\n * Execute a sequence test\n */\nasync function executeSequence(\n  client: ConformanceClient,\n  sequence: SequenceStep[],\n  context: Map<string, unknown>\n): Promise<void> {\n  for (const step of sequence) {\n    const result = await executeCall(client, step.call, step.args || [], context);\n    if (step.expect !== undefined) {\n      assertDeepEqual(result, step.expect, `Sequence step '${step.call}'`);\n    }\n  }\n}\n\n/**\n * Execute a simple call test\n */\nasync function executeSimpleCall(\n  client: ConformanceClient,\n  test: TestCase,\n  context: Map<string, unknown>\n): Promise<void> {\n  const resolvedArgs = resolveArgs(test.args || [], context, client);\n\n  if (test.expect_error) {\n    // Check if any_of contains a value option\n    const hasValueOption = test.expect_error.any_of?.some(\n      (opt) => typeof opt === 'object' && opt !== null && 'value' in opt\n    );\n\n    if (hasValueOption) {\n      // This test expects either an error OR a specific value\n      try {\n        const result = await executeCall(client, test.call!, resolvedArgs, context);\n        const valueOptions = test.expect_error.any_of?.filter(\n          (opt) => typeof opt === 'object' && opt !== null && 'value' in opt\n        ) as Array<{ value: unknown }>;\n\n        const matchesValue = valueOptions?.some((opt) => {\n          if (opt.value === null && (result === null || Number.isNaN(result))) {\n            return true;\n          }\n          return deepEqual(opt.value, result);\n        });\n\n        if (!matchesValue) {\n          throw new Error(`Result did not match any expected value`);\n        }\n      } catch (error) {\n        const err = error as Error;\n        if (test.expect_error.type && err.name !== test.expect_error.type) {\n          throw new Error(\n            `Expected error type '${test.expect_error.type}' but got '${err.name}'`\n          );\n        }\n        if (test.expect_error.message_contains && !err.message.includes(test.expect_error.message_contains)) {\n          throw new Error(\n            `Expected error message to contain '${test.expect_error.message_contains}' but got '${err.message}'`\n          );\n        }\n        // Error matched expectations\n      }\n    } else {\n      // Standard error test\n      let errorThrown = false;\n      let caughtError: Error | undefined;\n\n      try {\n        await executeCall(client, test.call!, resolvedArgs, context);\n      } catch (error) {\n        errorThrown = true;\n        caughtError = error as Error;\n      }\n\n      if (!errorThrown) {\n        throw new Error('Expected call to throw an error');\n      }\n\n      if (test.expect_error.type && caughtError!.name !== test.expect_error.type) {\n        throw new Error(\n          `Expected error type '${test.expect_error.type}' but got '${caughtError!.name}'`\n        );\n      }\n      if (\n        test.expect_error.message_contains &&\n        !caughtError!.message.includes(test.expect_error.message_contains)\n      ) {\n        throw new Error(\n          `Expected error message to contain '${test.expect_error.message_contains}' but got '${caughtError!.message}'`\n        );\n      }\n    }\n  } else {\n    const result = await executeCall(client, test.call!, resolvedArgs, context);\n    if (test.expect !== undefined) {\n      assertDeepEqual(result, test.expect, 'Call result');\n    }\n\n    // Check type expectations\n    if (test.expect_type === 'capability') {\n      if (!client.isCapabilityRef(result)) {\n        throw new Error('Expected result to be a capability reference');\n      }\n    }\n\n    if (test.expect_type === 'array_of_capabilities') {\n      if (!Array.isArray(result)) {\n        throw new Error('Expected result to be an array');\n      }\n      for (const item of result) {\n        if (!client.isCapabilityRef(item)) {\n          throw new Error('Expected all array items to be capability references');\n        }\n      }\n    }\n\n    // Check length\n    if (test.expect_length !== undefined) {\n      if (!Array.isArray(result)) {\n        throw new Error('Expected result to be an array for length check');\n      }\n      if (result.length !== test.expect_length) {\n        throw new Error(`Expected array length ${test.expect_length} but got ${result.length}`);\n      }\n    }\n\n    // Store result for verify steps\n    context.set('result', result);\n\n    // Verify steps\n    if (test.verify) {\n      for (const verify of test.verify) {\n        const verifyResult = await executeCall(client, verify.call, [], context);\n        assertDeepEqual(verifyResult, verify.expect, `Verify step '${verify.call}'`);\n      }\n    }\n  }\n}\n\n/**\n * Execute a single method call\n */\nasync function executeCall(\n  client: ConformanceClient,\n  call: string,\n  args: unknown[],\n  context: Map<string, unknown>\n): Promise<unknown> {\n  const resolvedArgs = resolveArgs(args, context, client);\n\n  // Check if it's a call on a context variable\n  if (call.startsWith('$')) {\n    const parts = call.substring(1).split('.');\n    const targetName = parts[0];\n    const method = parts.slice(1).join('.');\n\n    const target = context.get(targetName);\n    if (!target) {\n      throw new Error(`Unknown context variable: ${targetName}`);\n    }\n\n    return client.callOnCapability(target, method, ...resolvedArgs);\n  }\n\n  // Check if it's a dotted path (calling method on context variable)\n  const parts = call.split('.');\n  if (parts.length > 1) {\n    const targetName = parts[0];\n    const method = parts.slice(1).join('.');\n\n    const target = context.get(targetName);\n    if (target) {\n      return client.callOnCapability(target, method, ...resolvedArgs);\n    }\n  }\n\n  // Direct call on root\n  return client.call(call, ...resolvedArgs);\n}\n\n/**\n * Resolve argument references\n */\nfunction resolveArgs(\n  args: unknown[],\n  context: Map<string, unknown>,\n  client: ConformanceClient\n): unknown[] {\n  return args.map((arg) => {\n    if (typeof arg === 'string' && arg.startsWith('$')) {\n      const name = arg.substring(1);\n      if (name === 'self') {\n        return client.getSelf();\n      }\n      const value = context.get(name);\n      if (value !== undefined) {\n        return value;\n      }\n    }\n    return arg;\n  });\n}\n\n/**\n * Resolve pipeline argument references\n */\nfunction resolvePipelineArgs(\n  args: unknown[],\n  context: Map<string, unknown>,\n  stepNames: Set<string>,\n  client: ConformanceClient\n): unknown[] {\n  return args.map((arg) => {\n    if (typeof arg === 'string' && arg.startsWith('$')) {\n      const name = arg.substring(1);\n      if (name === 'self') {\n        return { $ref: 0 };\n      }\n      // If it's a step name, use $step reference\n      if (stepNames.has(name)) {\n        return { $step: name };\n      }\n      // Otherwise check context\n      const value = context.get(name);\n      if (value && client.isCapabilityRef(value)) {\n        return { $ref: (value as CapabilityRef).__capabilityId };\n      }\n      return value;\n    }\n    return arg;\n  });\n}\n\n/**\n * Deep equality check\n */\nfunction deepEqual(a: unknown, b: unknown): boolean {\n  if (a === b) return true;\n  if (a === null || b === null) return a === b;\n  if (typeof a !== typeof b) return false;\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    return a.every((item, i) => deepEqual(item, b[i]));\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const aKeys = Object.keys(a as object);\n    const bKeys = Object.keys(b as object);\n    if (aKeys.length !== bKeys.length) return false;\n    return aKeys.every((key) =>\n      deepEqual((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key])\n    );\n  }\n\n  return false;\n}\n\n/**\n * Assert deep equality with nice error message\n */\nfunction assertDeepEqual(actual: unknown, expected: unknown, context: string): void {\n  if (!deepEqual(actual, expected)) {\n    throw new Error(\n      `${context}: Expected ${JSON.stringify(expected)} but got ${JSON.stringify(actual)}`\n    );\n  }\n}\n","/**\n * Text reporter for console output\n */\n\nimport pc from 'picocolors';\nimport type { RunResult, SuiteResult, TestResult } from '../types.js';\n\n/**\n * Format test results as colored console output\n */\nexport function formatTextReport(result: RunResult, verbose: boolean): string {\n  const lines: string[] = [];\n\n  lines.push('');\n  lines.push(pc.bold('DotDo Conformance Test Results'));\n  lines.push(pc.dim(`Server: ${result.serverUrl}`));\n  lines.push(pc.dim(`Timestamp: ${result.timestamp}`));\n  lines.push('');\n\n  for (const suite of result.suites) {\n    lines.push(...formatSuite(suite, verbose));\n  }\n\n  // Summary\n  lines.push('');\n  lines.push(pc.bold('Summary'));\n  lines.push(pc.dim('â”€'.repeat(50)));\n\n  const totalTests = result.totalPassed + result.totalFailed + result.totalSkipped;\n\n  if (result.totalPassed > 0) {\n    lines.push(pc.green(`  ${result.totalPassed} passed`));\n  }\n  if (result.totalFailed > 0) {\n    lines.push(pc.red(`  ${result.totalFailed} failed`));\n  }\n  if (result.totalSkipped > 0) {\n    lines.push(pc.yellow(`  ${result.totalSkipped} skipped`));\n  }\n\n  lines.push(pc.dim(`  ${totalTests} total`));\n  lines.push(pc.dim(`  ${formatDuration(result.totalDuration)}`));\n  lines.push('');\n\n  // Final status\n  if (result.totalFailed === 0) {\n    lines.push(pc.green(pc.bold('All tests passed!')));\n  } else {\n    lines.push(pc.red(pc.bold(`${result.totalFailed} test(s) failed`)));\n  }\n  lines.push('');\n\n  return lines.join('\\n');\n}\n\n/**\n * Format a test suite\n */\nfunction formatSuite(suite: SuiteResult, verbose: boolean): string[] {\n  const lines: string[] = [];\n\n  // Suite header\n  const statusIcon = suite.failed > 0 ? pc.red('x') : pc.green('\\u2713');\n  lines.push(`${statusIcon} ${pc.bold(suite.name)} ${pc.dim(`(${formatDuration(suite.duration)})`)}`);\n\n  // Individual tests\n  for (const test of suite.tests) {\n    lines.push(formatTest(test, verbose));\n  }\n\n  // Suite summary if multiple tests\n  if (suite.tests.length > 1) {\n    const parts: string[] = [];\n    if (suite.passed > 0) parts.push(pc.green(`${suite.passed} passed`));\n    if (suite.failed > 0) parts.push(pc.red(`${suite.failed} failed`));\n    if (suite.skipped > 0) parts.push(pc.yellow(`${suite.skipped} skipped`));\n    lines.push(pc.dim(`  ${parts.join(', ')}`));\n  }\n\n  lines.push('');\n\n  return lines;\n}\n\n/**\n * Format a single test result\n */\nfunction formatTest(test: TestResult, verbose: boolean): string {\n  const parts: string[] = [];\n\n  // Status icon\n  switch (test.status) {\n    case 'passed':\n      parts.push(pc.green('    \\u2713'));\n      break;\n    case 'failed':\n      parts.push(pc.red('    x'));\n      break;\n    case 'skipped':\n      parts.push(pc.yellow('    -'));\n      break;\n  }\n\n  // Test name\n  parts.push(test.name);\n\n  // Duration\n  parts.push(pc.dim(`(${formatDuration(test.duration)})`));\n\n  let line = parts.join(' ');\n\n  // Error details for failed tests\n  if (test.status === 'failed' && test.error) {\n    line += '\\n' + pc.red(`      Error: ${test.error}`);\n    if (verbose && test.stackTrace) {\n      const stackLines = test.stackTrace.split('\\n').slice(0, 5);\n      line += '\\n' + pc.dim(stackLines.map((l) => `      ${l}`).join('\\n'));\n    }\n  }\n\n  // Skip reason\n  if (test.status === 'skipped' && test.skipReason) {\n    line += pc.dim(` - ${test.skipReason}`);\n  }\n\n  return line;\n}\n\n/**\n * Format a duration in ms to a human-readable string\n */\nfunction formatDuration(ms: number): string {\n  if (ms < 1000) {\n    return `${ms}ms`;\n  }\n  if (ms < 60000) {\n    return `${(ms / 1000).toFixed(2)}s`;\n  }\n  const minutes = Math.floor(ms / 60000);\n  const seconds = ((ms % 60000) / 1000).toFixed(1);\n  return `${minutes}m ${seconds}s`;\n}\n","/**\n * JSON reporter for machine-readable output\n */\n\nimport type { RunResult } from '../types.js';\n\n/**\n * Format test results as JSON\n */\nexport function formatJsonReport(result: RunResult): string {\n  return JSON.stringify(result, null, 2);\n}\n","/**\n * JUnit XML reporter for CI integration\n * Outputs test results in JUnit XML format\n */\n\nimport type { RunResult, SuiteResult, TestResult } from '../types.js';\n\n/**\n * Format test results as JUnit XML\n */\nexport function formatJUnitReport(result: RunResult): string {\n  const lines: string[] = [];\n\n  lines.push('<?xml version=\"1.0\" encoding=\"UTF-8\"?>');\n\n  // Calculate totals\n  const totalTests = result.totalPassed + result.totalFailed + result.totalSkipped;\n  const totalTime = result.totalDuration / 1000; // Convert to seconds\n\n  // Root testsuites element\n  lines.push(\n    `<testsuites name=\"DotDo Conformance Tests\" tests=\"${totalTests}\" failures=\"${result.totalFailed}\" errors=\"0\" skipped=\"${result.totalSkipped}\" time=\"${totalTime.toFixed(3)}\" timestamp=\"${result.timestamp}\">`\n  );\n\n  // Each suite\n  for (const suite of result.suites) {\n    lines.push(...formatSuite(suite));\n  }\n\n  lines.push('</testsuites>');\n\n  return lines.join('\\n');\n}\n\n/**\n * Format a single test suite\n */\nfunction formatSuite(suite: SuiteResult): string[] {\n  const lines: string[] = [];\n\n  const totalTests = suite.passed + suite.failed + suite.skipped;\n  const time = suite.duration / 1000;\n\n  // Escape the suite name for XML\n  const suiteName = escapeXml(suite.name);\n\n  lines.push(\n    `  <testsuite name=\"${suiteName}\" tests=\"${totalTests}\" failures=\"${suite.failed}\" errors=\"0\" skipped=\"${suite.skipped}\" time=\"${time.toFixed(3)}\">`\n  );\n\n  // Each test case\n  for (const test of suite.tests) {\n    lines.push(...formatTestCase(test, suite.name));\n  }\n\n  lines.push('  </testsuite>');\n\n  return lines;\n}\n\n/**\n * Format a single test case\n */\nfunction formatTestCase(test: TestResult, suiteName: string): string[] {\n  const lines: string[] = [];\n\n  const time = test.duration / 1000;\n  const testName = escapeXml(test.name);\n  const className = escapeXml(suiteName.replace(/\\s+/g, '.'));\n\n  lines.push(\n    `    <testcase name=\"${testName}\" classname=\"${className}\" time=\"${time.toFixed(3)}\">`\n  );\n\n  // Add failure or skip information\n  if (test.status === 'failed') {\n    const errorMessage = escapeXml(test.error || 'Test failed');\n    const errorType = 'AssertionError';\n\n    lines.push(`      <failure message=\"${errorMessage}\" type=\"${errorType}\">`);\n    if (test.stackTrace) {\n      lines.push(escapeXml(test.stackTrace));\n    }\n    lines.push('      </failure>');\n  } else if (test.status === 'skipped') {\n    const skipMessage = test.skipReason ? escapeXml(test.skipReason) : '';\n    lines.push(`      <skipped message=\"${skipMessage}\"/>`);\n  }\n\n  lines.push('    </testcase>');\n\n  return lines;\n}\n\n/**\n * Escape special characters for XML\n */\nfunction escapeXml(str: string): string {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&apos;');\n}\n"],"mappings":"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","names":["WebSocket","reject","parts","pc","formatSuite"]}