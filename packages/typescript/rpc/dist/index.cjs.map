{"version":3,"sources":["../src/promise.ts","../src/proxy.ts","../src/client.ts","../src/map.ts","../src/index.ts"],"names":[],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * RpcPromise - A Promise with pipelining support\n *\n * Enables chaining method calls without waiting for previous results,\n * allowing multiple operations to be batched into a single round trip.\n */\n\nimport type { RpcClient } from './client.js';\n\n/**\n * Operation type for pipeline\n */\nexport interface PipelineOp {\n  type: 'call' | 'get';\n  method?: string;\n  property?: string;\n  args?: unknown[];\n}\n\n/**\n * A promise that supports pipelining operations\n */\nexport class RpcPromise<T> extends Promise<T> {\n  private _client: RpcClient<unknown>;\n  private _ops: PipelineOp[];\n  private _capabilityId?: number;\n\n  constructor(\n    executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: unknown) => void) => void,\n    client: RpcClient<unknown>,\n    ops: PipelineOp[] = [],\n    capabilityId?: number\n  ) {\n    super(executor);\n    this._client = client;\n    this._ops = ops;\n    this._capabilityId = capabilityId;\n  }\n\n  /**\n   * Get a property from the result\n   */\n  get<K extends keyof T>(key: K): RpcPromise<T[K]> {\n    const newOps = [...this._ops, { type: 'get' as const, property: String(key) }];\n\n    return new RpcPromise<T[K]>(\n      (resolve, reject) => {\n        this.then(value => {\n          if (value && typeof value === 'object') {\n            resolve((value as Record<string, unknown>)[String(key)] as T[K]);\n          } else {\n            reject(new Error(`Cannot get property ${String(key)} of ${typeof value}`));\n          }\n        }).catch(reject);\n      },\n      this._client,\n      newOps,\n      this._capabilityId\n    );\n  }\n\n  /**\n   * Call a method on the result\n   */\n  call(method: string, ...args: unknown[]): RpcPromise<unknown> {\n    const newOps = [...this._ops, { type: 'call' as const, method, args }];\n\n    return new RpcPromise<unknown>(\n      (resolve, reject) => {\n        this.then(async value => {\n          // If value is a capability reference, call through the client\n          if (value && typeof value === 'object' && '__capabilityId' in (value as object)) {\n            const result = await this._client.callOnCapability(value, method, ...args);\n            resolve(result);\n          } else if (value && typeof value === 'object') {\n            const fn = (value as Record<string, unknown>)[method];\n            if (typeof fn === 'function') {\n              resolve(fn.apply(value, args));\n            } else {\n              reject(new Error(`${method} is not a function`));\n            }\n          } else {\n            reject(new Error(`Cannot call method on ${typeof value}`));\n          }\n        }).catch(reject);\n      },\n      this._client,\n      newOps,\n      this._capabilityId\n    );\n  }\n\n  /**\n   * Server-side map operation\n   * Maps a function over an array on the server, avoiding N round trips\n   */\n  map<U>(fn: (item: T extends (infer I)[] ? I : T) => U): RpcPromise<U[]> {\n    // Extract the function body for server execution\n    const fnStr = fn.toString();\n\n    return new RpcPromise<U[]>(\n      (resolve, reject) => {\n        this.then(async value => {\n          try {\n            const result = await this._client.serverMap(value, fnStr, {});\n            resolve(result as U[]);\n          } catch (error) {\n            reject(error);\n          }\n        }).catch(reject);\n      },\n      this._client,\n      this._ops,\n      this._capabilityId\n    );\n  }\n\n  /**\n   * Get the pipeline operations\n   */\n  getPipelineOps(): PipelineOp[] {\n    return [...this._ops];\n  }\n\n  /**\n   * Get the capability ID if this promise represents a capability\n   */\n  getCapabilityId(): number | undefined {\n    return this._capabilityId;\n  }\n\n  /**\n   * Create an RpcPromise from a regular promise\n   */\n  static from<T>(promise: Promise<T>, client: RpcClient<unknown>, ops: PipelineOp[] = [], capId?: number): RpcPromise<T> {\n    return new RpcPromise<T>(\n      (resolve, reject) => {\n        promise.then(resolve).catch(reject);\n      },\n      client,\n      ops,\n      capId\n    );\n  }\n}\n\n/**\n * Pipeline builder for batching multiple operations\n */\nexport class PipelineBuilder {\n  private _client: RpcClient<unknown>;\n  private _steps: Array<{\n    target?: string;\n    method: string;\n    args: unknown[];\n    as?: string;\n  }> = [];\n  private _lastAs?: string;\n\n  constructor(client: RpcClient<unknown>) {\n    this._client = client;\n  }\n\n  /**\n   * Add a method call to the pipeline\n   */\n  call(method: string, ...args: unknown[]): this {\n    this._steps.push({ method, args });\n    return this;\n  }\n\n  /**\n   * Call a method on a previously named result\n   */\n  callOn(targetName: string, method: string, ...args: unknown[]): this {\n    this._steps.push({ target: targetName, method, args });\n    return this;\n  }\n\n  /**\n   * Name the result of the previous step\n   */\n  as(name: string): this {\n    if (this._steps.length > 0) {\n      this._steps[this._steps.length - 1].as = name;\n      this._lastAs = name;\n    }\n    return this;\n  }\n\n  /**\n   * Execute the pipeline\n   */\n  async execute(): Promise<Record<string, unknown> & { __last: unknown }> {\n    return this._client.executePipeline(this._steps);\n  }\n}\n","/**\n * Proxy-based stub for zero-schema RPC access\n *\n * Enables natural method call syntax without predefined types:\n *   client.$.users.get({ id: 123 })\n */\n\nimport type { RpcClient, CapabilityRef } from './client.js';\nimport { RpcPromise } from './promise.js';\n\n/**\n * Proxy for a remote capability\n */\nexport interface CapabilityProxy {\n  [key: string]: CapabilityProxy | ((...args: unknown[]) => Promise<unknown>);\n}\n\n/**\n * Symbol for accessing the underlying capability ref\n */\nexport const CAPABILITY_REF = Symbol('capabilityRef');\n\n/**\n * Symbol for accessing the client\n */\nexport const CLIENT_REF = Symbol('clientRef');\n\n/**\n * Symbol for accessing the path\n */\nexport const PATH_REF = Symbol('pathRef');\n\n/**\n * Create a proxy for RPC method access\n *\n * @param client - The RPC client\n * @param path - Current path of property accesses\n * @param capabilityId - Optional capability ID for capability proxies\n */\nexport function createProxy<T>(\n  client: RpcClient<unknown>,\n  path: string[] = [],\n  capabilityId?: number\n): T {\n  const handler: ProxyHandler<object> = {\n    get(_target, prop: string | symbol): unknown {\n      // Handle special symbols\n      if (prop === CAPABILITY_REF) {\n        return capabilityId !== undefined ? { __capabilityId: capabilityId } : undefined;\n      }\n      if (prop === CLIENT_REF) {\n        return client;\n      }\n      if (prop === PATH_REF) {\n        return path;\n      }\n\n      // Ignore symbols and internal properties\n      if (typeof prop === 'symbol') {\n        return undefined;\n      }\n\n      // Handle promise methods\n      if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n        return undefined;  // Don't auto-thenable\n      }\n\n      // Build new path\n      const newPath = [...path, prop];\n\n      // Return a new proxy for chaining\n      return createProxy(client, newPath, capabilityId);\n    },\n\n    apply(_target, _thisArg, args: unknown[]): Promise<unknown> {\n      if (path.length === 0) {\n        throw new Error('Cannot call proxy root as a function');\n      }\n\n      const method = path[path.length - 1];\n\n      // If we have a capability ID, call on that capability\n      if (capabilityId !== undefined) {\n        return client.callOnCapability(\n          { __capabilityId: capabilityId },\n          method,\n          ...args\n        ).then(result => {\n          // If result is a capability, wrap it in a proxy\n          if (result && typeof result === 'object' && '__capabilityId' in result) {\n            return createCapabilityProxy(\n              client,\n              (result as CapabilityRef).__capabilityId\n            );\n          }\n          return result;\n        });\n      }\n\n      // Otherwise, call on root (capability 0)\n      return client.call(method, ...args).then(result => {\n        // If result is a capability, wrap it in a proxy\n        if (result && typeof result === 'object' && '__capabilityId' in result) {\n          return createCapabilityProxy(\n            client,\n            (result as CapabilityRef).__capabilityId\n          );\n        }\n        return result;\n      });\n    },\n  };\n\n  // Create a function as the target so the proxy is callable\n  const target = function () {} as unknown as T;\n  return new Proxy(target as object, handler) as T;\n}\n\n/**\n * Create a proxy specifically for a capability\n */\nexport function createCapabilityProxy(\n  client: RpcClient<unknown>,\n  capabilityId: number\n): CapabilityProxy & CapabilityRef {\n  const proxy = createProxy<CapabilityProxy>(client, [], capabilityId);\n\n  // Add __capabilityId for identification\n  Object.defineProperty(proxy, '__capabilityId', {\n    value: capabilityId,\n    writable: false,\n    enumerable: true,\n  });\n\n  return proxy as CapabilityProxy & CapabilityRef;\n}\n\n/**\n * Check if a value is a capability proxy\n */\nexport function isCapabilityProxy(value: unknown): value is CapabilityProxy {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof (value as Record<symbol, unknown>)[CAPABILITY_REF] === 'object'\n  );\n}\n\n/**\n * Get the capability reference from a proxy\n */\nexport function getCapabilityRef(proxy: CapabilityProxy): CapabilityRef | undefined {\n  return (proxy as Record<symbol, unknown>)[CAPABILITY_REF] as CapabilityRef | undefined;\n}\n\n/**\n * Get the client from a proxy\n */\nexport function getClient(proxy: CapabilityProxy): RpcClient<unknown> | undefined {\n  return (proxy as Record<symbol, unknown>)[CLIENT_REF] as RpcClient<unknown> | undefined;\n}\n\n/**\n * Typed proxy creator for better IDE support\n */\nexport function typed<T>(): <U extends RpcClient<T>>(client: U) => U {\n  return client => client;\n}\n","/**\n * RpcClient - The main RPC client with WebSocket transport\n *\n * Supports both real WebSocket connections and mock servers for testing.\n */\n\nimport type {\n  MockServerInterface,\n  RpcRequest,\n  RpcResponse,\n  PipelinedRequest,\n} from './types.js';\nimport { RpcPromise, PipelineBuilder } from './promise.js';\nimport { createProxy, CapabilityProxy } from './proxy.js';\n\n/**\n * Connection options\n */\nexport interface ConnectOptions {\n  /** Authentication token */\n  token?: string;\n  /** Custom headers */\n  headers?: Record<string, string>;\n  /** Connection timeout in ms */\n  timeout?: number;\n  /** Enable auto-reconnect */\n  autoReconnect?: boolean;\n}\n\n/**\n * Capability reference\n */\nexport interface CapabilityRef {\n  __capabilityId: number;\n}\n\n/**\n * Check if a value is a capability reference\n */\nexport function isCapabilityRef(value: unknown): value is CapabilityRef {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    '__capabilityId' in value &&\n    typeof (value as CapabilityRef).__capabilityId === 'number'\n  );\n}\n\n/**\n * Pipeline step for batched execution\n */\nexport interface PipelineStep {\n  target?: string;\n  method: string;\n  args: unknown[];\n  as?: string;\n}\n\n/**\n * RpcClient class\n */\nexport class RpcClient<T> {\n  private _nextRequestId = 1;\n  private _server: MockServerInterface | null = null;\n  private _ws: WebSocket | null = null;\n  private _url: string | null = null;\n  private _pending = new Map<number, { resolve: (v: unknown) => void; reject: (e: Error) => void }>();\n  private _capabilities = new Map<number, CapabilityProxy>();\n  private _exportedCallbacks = new Map<string, (x: number) => number>();\n  private _proxy: T;\n\n  constructor(serverOrUrl: MockServerInterface | string, _options?: ConnectOptions) {\n    if (typeof serverOrUrl === 'string') {\n      this._url = serverOrUrl;\n      // Real WebSocket connection would be established here\n      // For now, we just store the URL\n    } else {\n      this._server = serverOrUrl;\n    }\n\n    // Create the proxy for method access\n    this._proxy = createProxy(this, []) as T;\n  }\n\n  /**\n   * Proxy for direct method access\n   * Usage: client.$.methodName(args)\n   */\n  get $(): T {\n    return this._proxy;\n  }\n\n  /**\n   * Get self reference (capability ID 0)\n   */\n  getSelf(): CapabilityRef {\n    return { __capabilityId: 0 };\n  }\n\n  /**\n   * Export a callback function for server to call\n   */\n  exportCallback(name: string, fn: (x: number) => number): void {\n    this._exportedCallbacks.set(name, fn);\n  }\n\n  /**\n   * Get an exported callback\n   */\n  getExportedCallback(name: string): ((x: number) => number) | undefined {\n    return this._exportedCallbacks.get(name);\n  }\n\n  /**\n   * Make an RPC call\n   */\n  async call(method: string, ...args: unknown[]): Promise<unknown> {\n    const request: RpcRequest = {\n      id: this._nextRequestId++,\n      method,\n      target: 0,  // Root capability\n      args: this.serializeArgs(args),\n    };\n\n    return this.sendRequest(request);\n  }\n\n  /**\n   * Call a method on a capability\n   */\n  async callOnCapability(capability: unknown, method: string, ...args: unknown[]): Promise<unknown> {\n    let targetId: number;\n\n    if (isCapabilityRef(capability)) {\n      targetId = capability.__capabilityId;\n    } else if (typeof capability === 'object' && capability !== null && '$ref' in capability) {\n      targetId = (capability as { $ref: number }).$ref;\n    } else {\n      throw new Error('Invalid capability reference');\n    }\n\n    const request: RpcRequest = {\n      id: this._nextRequestId++,\n      method,\n      target: targetId,\n      args: this.serializeArgs(args),\n    };\n\n    return this.sendRequest(request);\n  }\n\n  /**\n   * Start building a pipeline\n   */\n  pipeline(): PipelineBuilder {\n    return new PipelineBuilder(this as unknown as RpcClient<unknown>);\n  }\n\n  /**\n   * Execute a pipeline using the server's native pipeline support\n   */\n  async executePipeline(steps: PipelineStep[]): Promise<Record<string, unknown> & { __last: unknown }> {\n    if (!this._server) {\n      throw new Error('Pipeline execution not yet supported over WebSocket');\n    }\n\n    // Convert to PipelinedRequest format\n    const pipelineSteps = steps.map(step => {\n      // Parse method to determine target\n      let method = step.method;\n      let target: number | string | undefined;\n\n      if (step.target) {\n        target = step.target;\n      }\n\n      // Resolve arguments - convert $name to step references\n      const resolvedArgs = step.args.map(arg => {\n        if (typeof arg === 'string' && arg.startsWith('$')) {\n          const name = arg.substring(1);\n          if (name === 'self') {\n            return { $ref: 0 };\n          }\n          return { $step: name };\n        }\n        if (isCapabilityRef(arg)) {\n          return { $ref: arg.__capabilityId };\n        }\n        return arg;\n      });\n\n      return {\n        method,\n        target,\n        args: resolvedArgs,\n        as: step.as,\n      };\n    });\n\n    const request: PipelinedRequest = {\n      id: this._nextRequestId++,\n      steps: pipelineSteps,\n    };\n\n    const responses = this._server.processPipeline(request);\n\n    // Build results\n    const results: Record<string, unknown> = {};\n    let lastResult: unknown;\n\n    for (const step of steps) {\n      if (step.as && responses[step.as]) {\n        const response = responses[step.as];\n        if (response.error) {\n          throw new Error(response.error.message);\n        }\n        results[step.as] = response.result;\n        lastResult = response.result;\n      }\n    }\n\n    return { ...results, __last: lastResult };\n  }\n\n  /**\n   * Server-side map operation - executes in a single round trip\n   */\n  async serverMap(\n    value: unknown,\n    expression: string,\n    captures: Record<string, unknown>\n  ): Promise<unknown> {\n    if (!this._server) {\n      throw new Error('Server map not yet supported over WebSocket');\n    }\n\n    // Handle null/undefined\n    if (value === null || value === undefined) {\n      return null;\n    }\n\n    // Get the capability ID for the value if it's a capability\n    let targetCapId: number;\n    if (isCapabilityRef(value)) {\n      targetCapId = value.__capabilityId;\n    } else {\n      // Register the value as a temporary capability (doesn't count as round trip)\n      targetCapId = this._server.registerCapability(value);\n    }\n\n    // Build captures with capability IDs\n    const captureIds: Record<string, number> = {};\n    for (const [name, cap] of Object.entries(captures)) {\n      if (isCapabilityRef(cap)) {\n        captureIds[name] = cap.__capabilityId;\n      } else if (cap && typeof cap === 'object' && '$ref' in cap) {\n        captureIds[name] = (cap as { $ref: number }).$ref;\n      } else {\n        // Register as temporary capability\n        captureIds[name] = this._server.registerCapability(cap);\n      }\n    }\n\n    const response = this._server.processMapRequest({\n      id: this._nextRequestId++,\n      target: targetCapId,\n      expression,\n      captures: captureIds,\n    });\n\n    if (response.error) {\n      throw new Error(response.error.message);\n    }\n\n    return response.result;\n  }\n\n  /**\n   * Execute a method call and map operation in a single round trip\n   */\n  async callAndMap(\n    method: string,\n    args: unknown[],\n    mapExpression: string,\n    captures: Record<string, unknown>\n  ): Promise<unknown> {\n    if (!this._server) {\n      throw new Error('callAndMap not yet supported over WebSocket');\n    }\n\n    // Build captures with capability IDs\n    const captureIds: Record<string, number> = {};\n    for (const [name, cap] of Object.entries(captures)) {\n      if (isCapabilityRef(cap)) {\n        captureIds[name] = cap.__capabilityId;\n      } else if (cap && typeof cap === 'object' && '$ref' in cap) {\n        captureIds[name] = (cap as { $ref: number }).$ref;\n      } else {\n        captureIds[name] = this._server.registerCapability(cap);\n      }\n    }\n\n    // Execute in a single batch: first call the method, then map\n    const request: RpcRequest = {\n      id: this._nextRequestId++,\n      method,\n      target: 0,\n      args: this.serializeArgs(args),\n    };\n\n    // Use processBatchWithMap which combines call + map in one round trip\n    const result = await this._server.processCallAndMap(request, mapExpression, captureIds);\n\n    if (result.error) {\n      throw new Error(result.error.message);\n    }\n\n    return result.result;\n  }\n\n  /**\n   * Close the connection\n   */\n  async close(): Promise<void> {\n    if (this._ws) {\n      this._ws.close();\n      this._ws = null;\n    }\n    this._server = null;\n    this._pending.clear();\n    this._capabilities.clear();\n  }\n\n  /**\n   * Send a request and wait for response\n   */\n  private async sendRequest(request: RpcRequest): Promise<unknown> {\n    if (this._server) {\n      // Mock server - direct call\n      const responses = this._server.processBatch([request]);\n      const response = responses[0];\n\n      if (response.error) {\n        const error = new Error(response.error.message);\n        error.name = response.error.type;\n        throw error;\n      }\n\n      // Handle capability results\n      if (response.capabilityId !== undefined) {\n        return { __capabilityId: response.capabilityId };\n      }\n\n      return response.result;\n    }\n\n    if (this._ws) {\n      // Real WebSocket - send and await response\n      return new Promise((resolve, reject) => {\n        this._pending.set(request.id, { resolve, reject });\n        this._ws!.send(JSON.stringify(request));\n      });\n    }\n\n    throw new Error('Not connected');\n  }\n\n  /**\n   * Handle incoming WebSocket message\n   */\n  private handleMessage(data: string): void {\n    const response = JSON.parse(data) as RpcResponse;\n    const pending = this._pending.get(response.id);\n\n    if (pending) {\n      this._pending.delete(response.id);\n\n      if (response.error) {\n        const error = new Error(response.error.message);\n        error.name = response.error.type;\n        pending.reject(error);\n      } else {\n        let result = response.result;\n        if (response.capabilityId !== undefined) {\n          result = { __capabilityId: response.capabilityId };\n        }\n        pending.resolve(result);\n      }\n    }\n  }\n\n  /**\n   * Serialize arguments, converting capability refs\n   */\n  private serializeArgs(args: unknown[]): unknown[] {\n    return args.map(arg => {\n      if (isCapabilityRef(arg)) {\n        return { $ref: arg.__capabilityId };\n      }\n      if (arg && typeof arg === 'object' && '$ref' in arg) {\n        return arg;  // Already serialized\n      }\n      return arg;\n    });\n  }\n\n  /**\n   * Resolve step arguments, converting named refs to capability IDs\n   */\n  private resolveStepArgs(args: unknown[], tempCaps: Map<string, number>): unknown[] {\n    return args.map(arg => {\n      if (typeof arg === 'string' && arg.startsWith('$')) {\n        const name = arg.substring(1);\n        if (name === 'self') {\n          return { $ref: 0 };\n        }\n        const capId = tempCaps.get(name);\n        if (capId !== undefined) {\n          return { $ref: capId };\n        }\n      }\n      if (isCapabilityRef(arg)) {\n        return { $ref: arg.__capabilityId };\n      }\n      return arg;\n    });\n  }\n}\n\n/**\n * Create an RpcPromise for a call\n */\nexport function createRpcPromise<T>(\n  client: RpcClient<unknown>,\n  method: string,\n  args: unknown[]\n): RpcPromise<T> {\n  return RpcPromise.from(\n    client.call(method, ...args) as Promise<T>,\n    client\n  );\n}\n","/**\n * Server-side .map() with record/replay support\n *\n * The key feature that eliminates N+1 round trips by executing\n * map operations on the server.\n */\n\nimport type { RpcClient, CapabilityRef } from './client.js';\nimport { RpcPromise } from './promise.js';\n\n/**\n * Recorded RPC call for replay\n */\nexport interface RecordedCall {\n  readonly timestamp: number;\n  readonly target: number;  // Capability ID\n  readonly method: string;\n  readonly args: unknown[];\n  readonly result?: unknown;\n  readonly error?: string;\n  readonly duration: number;\n}\n\n/**\n * Recording session containing multiple calls\n */\nexport interface Recording {\n  readonly id: string;\n  readonly startTime: number;\n  readonly endTime?: number;\n  readonly calls: readonly RecordedCall[];\n}\n\n/**\n * Map operation specification sent to server\n */\nexport interface MapSpec {\n  /** JavaScript expression to execute for each item */\n  expression: string;\n  /** Captured variables (capability IDs) */\n  captures: Record<string, number>;\n}\n\n/**\n * Result of server map operation\n */\nexport interface MapResult<T> {\n  /** The transformed array */\n  results: T[];\n  /** Number of round trips used */\n  roundTrips: number;\n  /** Any errors that occurred */\n  errors?: Array<{ index: number; error: string }>;\n}\n\n/**\n * Options for the map operation\n */\nexport interface MapOptions {\n  /** Enable recording of the map operation */\n  record?: boolean;\n  /** Execute from recorded data instead of making real calls */\n  replay?: Recording;\n  /** Transform function applied to results */\n  transform?: <T>(result: T, index: number) => T;\n  /** Error handling mode */\n  onError?: 'throw' | 'skip' | 'null';\n}\n\n/**\n * Recorder class for capturing RPC calls\n */\nexport class RpcRecorder {\n  private _recording: boolean = false;\n  private _calls: RecordedCall[] = [];\n  private _startTime: number = 0;\n\n  /**\n   * Start recording\n   */\n  start(): void {\n    this._recording = true;\n    this._calls = [];\n    this._startTime = Date.now();\n  }\n\n  /**\n   * Stop recording and return the recording\n   */\n  stop(): Recording {\n    this._recording = false;\n    return {\n      id: crypto.randomUUID(),\n      startTime: this._startTime,\n      endTime: Date.now(),\n      calls: Object.freeze([...this._calls]),\n    };\n  }\n\n  /**\n   * Check if currently recording\n   */\n  get isRecording(): boolean {\n    return this._recording;\n  }\n\n  /**\n   * Record a call\n   */\n  recordCall(call: Omit<RecordedCall, 'timestamp'>): void {\n    if (this._recording) {\n      this._calls.push({\n        ...call,\n        timestamp: Date.now(),\n      });\n    }\n  }\n}\n\n/**\n * Replayer class for executing from recorded data\n */\nexport class RpcReplayer {\n  private _recording: Recording;\n  private _index: number = 0;\n\n  constructor(recording: Recording) {\n    this._recording = recording;\n  }\n\n  /**\n   * Get the next recorded call result\n   */\n  next(): RecordedCall | undefined {\n    if (this._index < this._recording.calls.length) {\n      return this._recording.calls[this._index++];\n    }\n    return undefined;\n  }\n\n  /**\n   * Reset to the beginning\n   */\n  reset(): void {\n    this._index = 0;\n  }\n\n  /**\n   * Check if there are more calls\n   */\n  hasMore(): boolean {\n    return this._index < this._recording.calls.length;\n  }\n}\n\n/**\n * Execute a server-side map operation\n *\n * This is the core function that eliminates N+1 round trips by\n * sending the map expression to the server for execution.\n *\n * @param client - The RPC client\n * @param array - The array to map over (or promise of array)\n * @param fn - The mapping function\n * @param options - Map options\n */\nexport async function serverMap<T, U>(\n  client: RpcClient<unknown>,\n  array: T[] | Promise<T[]>,\n  fn: (item: T) => U,\n  options?: MapOptions\n): Promise<U[]> {\n  // Resolve the array if it's a promise\n  const resolvedArray = await array;\n\n  // Handle null/undefined\n  if (resolvedArray === null || resolvedArray === undefined) {\n    return [] as unknown as U[];\n  }\n\n  // Handle empty array\n  if (resolvedArray.length === 0) {\n    return [];\n  }\n\n  // Extract the function body for server execution\n  const fnStr = fn.toString();\n\n  // Execute via client's serverMap\n  const result = await client.serverMap(resolvedArray, fnStr, {});\n\n  // Apply transform if specified\n  if (options?.transform && Array.isArray(result)) {\n    return result.map((item, index) => options.transform!(item as U, index));\n  }\n\n  return result as U[];\n}\n\n/**\n * Create a server map operation from a capability\n */\nexport function createServerMap<T extends unknown[], U>(\n  client: RpcClient<unknown>,\n  capabilityId: number\n): {\n  map<V>(fn: (item: T[number]) => V): Promise<V[]>;\n} {\n  return {\n    async map<V>(fn: (item: T[number]) => V): Promise<V[]> {\n      const fnStr = fn.toString();\n      const result = await client.serverMap(\n        { __capabilityId: capabilityId } as unknown,\n        fnStr,\n        {}\n      );\n      return result as V[];\n    },\n  };\n}\n\n/**\n * Serialize a function for transmission to server\n *\n * This extracts the function body and any captured variables.\n */\nexport function serializeFunction(fn: Function): { expression: string; captures: string[] } {\n  const fnStr = fn.toString();\n\n  // Extract captured variable names (simple heuristic)\n  const captures: string[] = [];\n\n  // Look for $name patterns indicating captured capabilities\n  const captureRegex = /\\$(\\w+)/g;\n  let match;\n  while ((match = captureRegex.exec(fnStr)) !== null) {\n    if (!captures.includes(match[1])) {\n      captures.push(match[1]);\n    }\n  }\n\n  return {\n    expression: fnStr,\n    captures,\n  };\n}\n\n/**\n * Deserialize a function from server\n */\nexport function deserializeFunction(spec: { expression: string; captures: Record<string, unknown> }): Function {\n  const args = Object.keys(spec.captures);\n  const body = `return (${spec.expression})(item)`;\n  return new Function(...args, 'item', body);\n}\n","/**\n * rpc.do - Promise Pipelining RPC for .do services\n *\n * Zero-schema, type-safe RPC with promise pipelining that eliminates\n * N+1 round trips through server-side .map() operations.\n *\n * @example\n * ```typescript\n * import { connect } from 'rpc.do'\n *\n * // Connect to a .do service\n * const client = connect('wss://api.example.do')\n *\n * // Call methods directly via proxy\n * const result = await client.$.square(5)\n *\n * // Use capabilities\n * const counter = await client.$.makeCounter(10)\n * const value = await counter.increment(5)\n *\n * // Server-side map (single round trip!)\n * const numbers = await client.$.generateFibonacci(10)\n * const squared = await client.serverMap(numbers, 'x => self.square(x)', { self: client.getSelf() })\n * ```\n *\n * @packageDocumentation\n */\n\n// Core client\nexport { RpcClient, isCapabilityRef, createRpcPromise } from './client.js';\nexport type { ConnectOptions, CapabilityRef, PipelineStep } from './client.js';\n\n// Promise with pipelining\nexport { RpcPromise, PipelineBuilder } from './promise.js';\nexport type { PipelineOp } from './promise.js';\n\n// Proxy access\nexport {\n  createProxy,\n  createCapabilityProxy,\n  isCapabilityProxy,\n  getCapabilityRef,\n  getClient,\n  typed,\n  CAPABILITY_REF,\n  CLIENT_REF,\n  PATH_REF,\n} from './proxy.js';\nexport type { CapabilityProxy } from './proxy.js';\n\n// Map operations\nexport {\n  RpcRecorder,\n  RpcReplayer,\n  serverMap,\n  createServerMap,\n  serializeFunction,\n  deserializeFunction,\n} from './map.js';\nexport type {\n  RecordedCall,\n  Recording,\n  MapSpec,\n  MapResult,\n  MapOptions,\n} from './map.js';\n\n// Protocol types (for implementing mock servers or custom transports)\nexport type {\n  MockServerInterface,\n  RpcRequest,\n  RpcResponse,\n  RpcMapRequest,\n  PipelinedRequest,\n  PipelineOp as ProtocolPipelineOp,\n} from './types.js';\n\n// Import for the connect function\nimport { RpcClient, ConnectOptions } from './client.js';\nimport type { MockServerInterface } from './types.js';\n\n/**\n * Connect to an RPC service\n *\n * @param serverOrUrl - Either a WebSocket URL or a MockServer for testing\n * @param options - Connection options\n * @returns An RpcClient instance\n *\n * @example\n * ```typescript\n * // Connect to a real service\n * const client = connect('wss://api.example.do')\n *\n * // Connect with authentication\n * const client = connect('wss://api.example.do', {\n *   token: 'your-api-key'\n * })\n *\n * // Connect to mock server (testing)\n * const server = new MockServer()\n * const client = connect(server)\n * ```\n */\nexport function connect<T = unknown>(\n  serverOrUrl: MockServerInterface | string,\n  options?: ConnectOptions\n): RpcClient<T> {\n  return new RpcClient<T>(serverOrUrl, options);\n}\n\n/**\n * Type helper for defining service interfaces\n *\n * @example\n * ```typescript\n * interface MyService {\n *   square(x: number): Promise<number>\n *   makeCounter(initial: number): Promise<Counter>\n * }\n *\n * interface Counter {\n *   value(): Promise<number>\n *   increment(by: number): Promise<number>\n * }\n *\n * const client = connect<MyService>('wss://my.service.do')\n * const result = await client.$.square(5)  // TypeScript knows this returns Promise<number>\n * ```\n */\nexport type ServiceInterface<T> = {\n  [K in keyof T]: T[K] extends (...args: infer A) => Promise<infer R>\n    ? (...args: A) => Promise<R>\n    : T[K] extends (...args: infer A) => infer R\n    ? (...args: A) => Promise<Awaited<R>>\n    : T[K] extends object\n    ? ServiceInterface<T[K]>\n    : T[K];\n};\n\n// ============================================================================\n// Error Types - Re-exported from @dotdo/capnweb (single source of truth)\n// ============================================================================\n\n/**\n * Error types are re-exported from @dotdo/capnweb to ensure a single source\n * of truth and consistent instanceof checks across all packages.\n *\n * Error Hierarchy:\n * - CapnwebError (base) - defined in @dotdo/capnweb\n *   - ConnectionError - Connection failures\n *   - RpcError - Method call failures\n *   - CapabilityError - Capability resolution failures\n *   - TimeoutError - Request timeout\n *   - SerializationError - Encoding/decoding failures\n *\n * @see {@link CapnwebError} for catching all RPC-related errors\n */\nexport {\n  // Error classes\n  CapnwebError,\n  ConnectionError,\n  RpcError,\n  CapabilityError,\n  TimeoutError,\n  SerializationError,\n  // Error codes and utilities\n  ErrorCode,\n  ErrorCodeName,\n  isErrorCode,\n  createError,\n  wrapError,\n} from '@dotdo/capnweb';\nexport type { ErrorCodeType } from '@dotdo/capnweb';\n"]}