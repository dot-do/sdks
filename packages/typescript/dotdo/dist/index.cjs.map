{"version":3,"sources":["../src/index.ts"],"names":["rpcConnect","queue","TimeoutError","CapnwebError"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * dotdo - DotDo Platform SDK\n * Managed connections to .do services with authentication, pooling, and retry logic\n */\n\nimport {\n  connect as rpcConnect,\n  RpcClient,\n  TimeoutError,\n  CapnwebError,\n  type ConnectOptions,\n} from 'rpc.do';\n\n// Type aliases for compatibility - these represent the actual RPC types\nexport type RpcProxy<T = unknown> = RpcClient<T>;\nexport type $ = unknown;\nexport type RpcConnectionOptions = ConnectOptions & {\n  url?: string;\n  headers?: Record<string, string>;\n  apiKey?: string;\n  timeout?: number;\n  signal?: AbortSignal;\n};\n\n// Connection interface for pooled connections\nexport interface Connection {\n  close(reason?: string): Promise<void>;\n}\n\n// Map operation types\nexport interface Recording {\n  calls: RecordedCall[];\n}\n\nexport interface MapOptions {\n  captures?: Record<string, unknown>;\n}\n\nexport interface RecordedCall {\n  method: string;\n  args: unknown[];\n  result?: unknown;\n}\n\n// Helper to create a connection (returns client and a close handle)\nfunction createConnection(options: RpcConnectionOptions): { connection: Connection; proxy: RpcProxy } {\n  const client = rpcConnect(options.url || '', options);\n  return {\n    connection: {\n      close: async (_reason?: string) => {\n        await client.close();\n      },\n    },\n    proxy: client,\n  };\n}\n\n// Re-export connect for convenience\nexport { rpcConnect as connect };\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\n/**\n * Authentication options for DotDo services\n */\nexport interface AuthOptions {\n  /** API key for authentication */\n  apiKey?: string;\n  /** OAuth access token */\n  accessToken?: string;\n  /** Custom authentication headers */\n  headers?: Record<string, string>;\n}\n\n/**\n * Connection pool configuration\n */\nexport interface PoolOptions {\n  /** Minimum number of connections to maintain */\n  minConnections?: number;\n  /** Maximum number of connections allowed */\n  maxConnections?: number;\n  /** Time in ms before an idle connection is closed */\n  idleTimeout?: number;\n  /** Time in ms to wait for an available connection (default: 30000) */\n  acquireTimeout?: number;\n}\n\n/**\n * Options for acquiring a connection from the pool\n */\nexport interface AcquireOptions {\n  /** Timeout in milliseconds for acquiring a connection (default: 30000) */\n  timeout?: number;\n  /** Optional AbortSignal to cancel the acquire operation */\n  signal?: AbortSignal;\n}\n\n/**\n * Retry configuration\n */\nexport interface RetryOptions {\n  /** Maximum number of retry attempts */\n  maxAttempts?: number;\n  /** Base delay in ms between retries */\n  baseDelay?: number;\n  /** Maximum delay in ms between retries */\n  maxDelay?: number;\n  /** Multiplier for exponential backoff */\n  backoffMultiplier?: number;\n  /** HTTP status codes that should trigger a retry */\n  retryableStatuses?: number[];\n  /** Error codes that should trigger a retry */\n  retryableErrors?: string[];\n  /** Timeout in ms for the entire retry operation (default: no timeout) */\n  timeout?: number;\n  /** Optional AbortSignal to cancel retry operation */\n  signal?: AbortSignal;\n}\n\n/**\n * Full DotDo client configuration\n */\nexport interface DotDoOptions {\n  /** API key for authentication */\n  apiKey?: string;\n  /** Full authentication options */\n  auth?: AuthOptions;\n  /** Connection pool settings */\n  pool?: PoolOptions;\n  /** Retry behavior settings */\n  retry?: RetryOptions;\n  /** Default timeout for requests in ms */\n  timeout?: number;\n  /** Base URL override (default: https://{service}.do) */\n  baseUrl?: string;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n// ============================================================================\n// Connection Pool\n// ============================================================================\n\ninterface PooledConnection {\n  connection: Connection;\n  proxy: RpcProxy;\n  lastUsed: number;\n  inUse: boolean;\n}\n\n/**\n * Connection pool manager\n */\nclass ConnectionPool {\n  private connections: Map<string, PooledConnection[]> = new Map();\n  private readonly options: Required<PoolOptions>;\n  /** Pending acquire operations waiting for a connection */\n  private waitQueue: Map<string, Array<{\n    resolve: (pooled: PooledConnection) => void;\n    reject: (error: Error) => void;\n  }>> = new Map();\n\n  constructor(options: PoolOptions = {}) {\n    this.options = {\n      minConnections: options.minConnections ?? 1,\n      maxConnections: options.maxConnections ?? 10,\n      idleTimeout: options.idleTimeout ?? 30000,\n      acquireTimeout: options.acquireTimeout ?? 30000, // Default 30s as per issue spec\n    };\n  }\n\n  /**\n   * Acquire a connection from the pool\n   *\n   * @param url - The URL to connect to\n   * @param connectionOptions - Options for creating a new connection\n   * @param acquireOptions - Options for the acquire operation (timeout, signal)\n   */\n  async acquire(\n    url: string,\n    connectionOptions: RpcConnectionOptions,\n    acquireOptions?: AcquireOptions\n  ): Promise<{ connection: Connection; proxy: RpcProxy }> {\n    const timeout = acquireOptions?.timeout ?? this.options.acquireTimeout;\n    const externalSignal = acquireOptions?.signal;\n\n    // Create internal AbortController for timeout\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    // If external signal provided, listen for abort\n    const onExternalAbort = () => controller.abort();\n    externalSignal?.addEventListener('abort', onExternalAbort);\n\n    try {\n      return await this.acquireInternal(url, connectionOptions, controller.signal, timeout);\n    } finally {\n      clearTimeout(timeoutId);\n      externalSignal?.removeEventListener('abort', onExternalAbort);\n    }\n  }\n\n  /**\n   * Internal acquire implementation that respects AbortSignal\n   */\n  private async acquireInternal(\n    url: string,\n    connectionOptions: RpcConnectionOptions,\n    signal: AbortSignal,\n    timeout: number\n  ): Promise<{ connection: Connection; proxy: RpcProxy }> {\n    // Check if already aborted\n    if (signal.aborted) {\n      throw new PoolTimeoutError(\n        `Connection pool acquire timeout for ${url} after ${timeout}ms`,\n        url,\n        timeout\n      );\n    }\n\n    let pool = this.connections.get(url);\n    if (!pool) {\n      pool = [];\n      this.connections.set(url, pool);\n    }\n\n    // Try to find an available connection\n    for (const pooled of pool) {\n      if (!pooled.inUse) {\n        pooled.inUse = true;\n        pooled.lastUsed = Date.now();\n        return { connection: pooled.connection, proxy: pooled.proxy };\n      }\n    }\n\n    // Create a new connection if under limit\n    if (pool.length < this.options.maxConnections) {\n      // Check abort before creating connection\n      if (signal.aborted) {\n        throw new PoolTimeoutError(\n          `Connection pool acquire timeout for ${url} after ${timeout}ms`,\n          url,\n          timeout\n        );\n      }\n\n      // Pass signal to connection options for propagation to underlying transport\n      const connectionOptionsWithSignal: RpcConnectionOptions = {\n        ...connectionOptions,\n        signal, // Propagate signal to WebSocket/transport\n      };\n\n      const { connection, proxy } = createConnection(connectionOptionsWithSignal);\n      const pooled: PooledConnection = {\n        connection,\n        proxy,\n        lastUsed: Date.now(),\n        inUse: true,\n      };\n      pool.push(pooled);\n      return { connection, proxy };\n    }\n\n    // Pool is at capacity - wait for an available connection\n    return this.waitForConnection(url, signal, timeout);\n  }\n\n  /**\n   * Wait for a connection to become available (pool exhausted)\n   */\n  private waitForConnection(\n    url: string,\n    signal: AbortSignal,\n    timeout: number\n  ): Promise<{ connection: Connection; proxy: RpcProxy }> {\n    return new Promise((resolve, reject) => {\n      const pool = this.connections.get(url)!;\n\n      // Handler for when signal is aborted\n      const onAbort = () => {\n        // Remove from wait queue\n        const queue = this.waitQueue.get(url);\n        if (queue) {\n          const index = queue.findIndex((w) => w.resolve === waiterResolve);\n          if (index !== -1) {\n            queue.splice(index, 1);\n          }\n        }\n        reject(\n          new PoolTimeoutError(\n            `Connection pool acquire timeout for ${url} after ${timeout}ms`,\n            url,\n            timeout\n          )\n        );\n      };\n\n      // If already aborted, reject immediately\n      if (signal.aborted) {\n        onAbort();\n        return;\n      }\n\n      // Waiter callbacks\n      const waiterResolve = (pooled: PooledConnection) => {\n        signal.removeEventListener('abort', onAbort);\n        pooled.inUse = true;\n        pooled.lastUsed = Date.now();\n        resolve({ connection: pooled.connection, proxy: pooled.proxy });\n      };\n\n      const waiterReject = (error: Error) => {\n        signal.removeEventListener('abort', onAbort);\n        reject(error);\n      };\n\n      // Add to wait queue\n      let queue = this.waitQueue.get(url);\n      if (!queue) {\n        queue = [];\n        this.waitQueue.set(url, queue);\n      }\n      queue.push({ resolve: waiterResolve, reject: waiterReject });\n\n      // Listen for abort\n      signal.addEventListener('abort', onAbort);\n\n      // Start polling for available connections\n      const pollInterval = setInterval(() => {\n        if (signal.aborted) {\n          clearInterval(pollInterval);\n          return;\n        }\n\n        for (const pooled of pool) {\n          if (!pooled.inUse) {\n            clearInterval(pollInterval);\n            // Remove from queue\n            const q = this.waitQueue.get(url);\n            if (q) {\n              const idx = q.findIndex((w) => w.resolve === waiterResolve);\n              if (idx !== -1) {\n                q.splice(idx, 1);\n              }\n            }\n            waiterResolve(pooled);\n            return;\n          }\n        }\n      }, 50);\n    });\n  }\n\n  /**\n   * Release a connection back to the pool\n   */\n  release(url: string, connection: Connection): void {\n    const pool = this.connections.get(url);\n    if (!pool) return;\n\n    for (const pooled of pool) {\n      if (pooled.connection === connection) {\n        pooled.inUse = false;\n        pooled.lastUsed = Date.now();\n        return;\n      }\n    }\n  }\n\n  /**\n   * Clean up idle connections\n   */\n  cleanup(): void {\n    const now = Date.now();\n    for (const [url, pool] of this.connections) {\n      const active = pool.filter((p) => {\n        if (p.inUse) return true;\n        if (now - p.lastUsed > this.options.idleTimeout) {\n          p.connection.close('idle timeout');\n          return false;\n        }\n        return true;\n      });\n      if (active.length === 0) {\n        this.connections.delete(url);\n      } else {\n        this.connections.set(url, active);\n      }\n    }\n  }\n\n  /**\n   * Close all connections\n   */\n  async closeAll(): Promise<void> {\n    for (const pool of this.connections.values()) {\n      for (const pooled of pool) {\n        await pooled.connection.close('pool shutdown');\n      }\n    }\n    this.connections.clear();\n  }\n}\n\n// ============================================================================\n// Retry Logic\n// ============================================================================\n\n// Type for internal retry options with required fields except signal\ntype InternalRetryOptions = Omit<Required<RetryOptions>, 'signal' | 'timeout'> & {\n  timeout?: number;\n  signal?: AbortSignal;\n};\n\nconst DEFAULT_RETRY_OPTIONS: InternalRetryOptions = {\n  maxAttempts: 3,\n  baseDelay: 100,\n  maxDelay: 10000,\n  backoffMultiplier: 2,\n  retryableStatuses: [408, 429, 500, 502, 503, 504],\n  retryableErrors: ['ECONNRESET', 'ETIMEDOUT', 'ECONNREFUSED', 'CONNECTION_ERROR'],\n  timeout: undefined,\n  signal: undefined,\n};\n\n/**\n * Calculate delay for retry attempt using exponential backoff with jitter\n */\nfunction calculateRetryDelay(attempt: number, options: InternalRetryOptions): number {\n  const exponentialDelay = options.baseDelay * Math.pow(options.backoffMultiplier, attempt);\n  const cappedDelay = Math.min(exponentialDelay, options.maxDelay);\n  // Add jitter (0-25% of delay)\n  const jitter = cappedDelay * Math.random() * 0.25;\n  return cappedDelay + jitter;\n}\n\n/**\n * Check if an error is retryable\n */\nfunction isRetryableError(error: unknown, options: InternalRetryOptions): boolean {\n  if (error instanceof Error) {\n    const code = (error as Error & { code?: string }).code;\n    if (code && options.retryableErrors.includes(code)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Execute a function with retry logic\n */\nasync function withRetry<T>(\n  fn: () => Promise<T>,\n  options: InternalRetryOptions,\n  onRetry?: (attempt: number, error: unknown) => void\n): Promise<T> {\n  let lastError: unknown;\n  const startTime = Date.now();\n\n  // Check if already aborted\n  if (options.signal?.aborted) {\n    const err = new Error('Operation aborted');\n    err.name = 'AbortError';\n    throw err;\n  }\n\n  for (let attempt = 0; attempt < options.maxAttempts; attempt++) {\n    // Check timeout before each attempt\n    if (options.timeout && Date.now() - startTime >= options.timeout) {\n      throw new TimeoutError(`Retry operation timed out after ${options.timeout}ms`);\n    }\n\n    // Check abort signal before each attempt\n    if (options.signal?.aborted) {\n      const err = new Error('Operation aborted');\n      err.name = 'AbortError';\n      throw err;\n    }\n\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      if (attempt < options.maxAttempts - 1 && isRetryableError(error, options)) {\n        const delay = calculateRetryDelay(attempt, options);\n        onRetry?.(attempt + 1, error);\n\n        // Check if delay would exceed timeout\n        if (options.timeout) {\n          const elapsed = Date.now() - startTime;\n          const remainingTime = options.timeout - elapsed;\n          if (remainingTime <= 0) {\n            throw new TimeoutError(`Retry operation timed out after ${options.timeout}ms`);\n          }\n          // Cap delay to remaining time\n          const cappedDelay = Math.min(delay, remainingTime);\n          await new Promise((resolve) => setTimeout(resolve, cappedDelay));\n        } else {\n          await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  throw lastError;\n}\n\n\n// ============================================================================\n// DotDo Client\n// ============================================================================\n\n/**\n * DotDo Platform Client\n *\n * Provides managed connections to .do services with:\n * - Authentication (API key, OAuth, custom headers)\n * - Connection pooling\n * - Automatic retry with exponential backoff\n * - Request timeout handling\n *\n * @example\n * ```ts\n * // Create a client with API key\n * const dotdo = new DotDo({ apiKey: 'your-api-key' });\n *\n * // Connect to a service\n * const ai = await dotdo.connect<AIService>('ai');\n * const result = await ai.generate({ prompt: 'Hello!' });\n *\n * // Or use the full URL\n * const custom = await dotdo.connect('https://custom.example.do');\n * ```\n */\nexport class DotDo {\n  private readonly options: DotDoOptions;\n  private readonly pool: ConnectionPool;\n  private readonly retryOptions: InternalRetryOptions;\n  private cleanupInterval?: ReturnType<typeof setInterval>;\n\n  constructor(options: DotDoOptions = {}) {\n    this.options = options;\n    this.pool = new ConnectionPool(options.pool);\n    this.retryOptions = { ...DEFAULT_RETRY_OPTIONS, ...options.retry };\n\n    // Start cleanup interval\n    this.cleanupInterval = setInterval(() => this.pool.cleanup(), 10000);\n  }\n\n  /**\n   * Connect to a .do service\n   *\n   * @param service - Service name (e.g., 'ai') or full URL\n   * @returns Typed RPC proxy for the service\n   *\n   * @example\n   * ```ts\n   * // Connect by service name\n   * const ai = await dotdo.connect<AIService>('ai');\n   *\n   * // Connect by full URL\n   * const api = await dotdo.connect('https://api.example.do');\n   * ```\n   */\n  async connect<T = $>(service: string): Promise<RpcProxy<T>> {\n    const url = this.resolveUrl(service);\n    const connectionOptions = this.buildConnectionOptions(url);\n\n    const { proxy } = await withRetry(\n      () => this.pool.acquire(url, connectionOptions),\n      this.retryOptions,\n      this.options.debug ? (attempt, error) => {\n        console.log(`[DotDo] Retry attempt ${attempt} for ${url}:`, error);\n      } : undefined\n    );\n\n    return this.wrapWithRetry(proxy as RpcProxy<T>, url);\n  }\n\n  /**\n   * Create a one-off connection without pooling\n   *\n   * @param service - Service name or full URL\n   * @returns Connection and proxy\n   */\n  connectOnce<T = $>(service: string): RpcProxy<T> {\n    const url = this.resolveUrl(service);\n    const connectionOptions = this.buildConnectionOptions(url);\n    return rpcConnect<T>(url, connectionOptions);\n  }\n\n  /**\n   * Get authentication headers for the current configuration\n   */\n  getAuthHeaders(): Record<string, string> {\n    const headers: Record<string, string> = {};\n\n    if (this.options.apiKey) {\n      headers['Authorization'] = `Bearer ${this.options.apiKey}`;\n    }\n\n    if (this.options.auth?.apiKey) {\n      headers['Authorization'] = `Bearer ${this.options.auth.apiKey}`;\n    }\n\n    if (this.options.auth?.accessToken) {\n      headers['Authorization'] = `Bearer ${this.options.auth.accessToken}`;\n    }\n\n    if (this.options.auth?.headers) {\n      Object.assign(headers, this.options.auth.headers);\n    }\n\n    return headers;\n  }\n\n  /**\n   * Close all connections and clean up resources\n   */\n  async close(): Promise<void> {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval);\n      this.cleanupInterval = undefined;\n    }\n    await this.pool.closeAll();\n  }\n\n  /**\n   * Resolve a service name to a full URL\n   */\n  private resolveUrl(service: string): string {\n    // If already a URL, use as-is\n    if (service.includes('://')) {\n      return service;\n    }\n\n    // If base URL is provided, use it\n    if (this.options.baseUrl) {\n      return `${this.options.baseUrl}/${service}`;\n    }\n\n    // Default to .do domain\n    return `https://${service}.do`;\n  }\n\n  /**\n   * Build connection options with auth\n   */\n  private buildConnectionOptions(url: string): RpcConnectionOptions {\n    return {\n      url,\n      timeout: this.options.timeout,\n      headers: this.getAuthHeaders(),\n      apiKey: this.options.apiKey || this.options.auth?.apiKey,\n    };\n  }\n\n  /**\n   * Wrap a proxy with retry logic\n   */\n  private wrapWithRetry<T>(proxy: RpcProxy<T>, _url: string): RpcProxy<T> {\n    // The proxy already handles individual call retries through the map() functionality\n    // This is a hook point for adding connection-level retry logic\n    return proxy;\n  }\n}\n\n// ============================================================================\n// Convenience Functions\n// ============================================================================\n\nlet defaultClient: DotDo | undefined;\n\n/**\n * Get or create the default DotDo client\n *\n * @param options - Options for creating the client (only used on first call)\n */\nexport function getClient(options?: DotDoOptions): DotDo {\n  if (!defaultClient) {\n    defaultClient = new DotDo(options);\n  }\n  return defaultClient;\n}\n\n/**\n * Configure the default client\n *\n * @param options - Client options\n */\nexport function configure(options: DotDoOptions): DotDo {\n  if (defaultClient) {\n    defaultClient.close();\n  }\n  defaultClient = new DotDo(options);\n  return defaultClient;\n}\n\n/**\n * Quick connect to a .do service using the default client\n *\n * @param service - Service name or URL\n * @param options - Override options for this connection\n *\n * @example\n * ```ts\n * import { to } from 'dotdo';\n *\n * const ai = await to<AIService>('ai');\n * const result = await ai.generate({ prompt: 'Hello!' });\n * ```\n */\nexport async function to<T = $>(\n  service: string,\n  options?: DotDoOptions\n): Promise<RpcProxy<T>> {\n  const client = options ? new DotDo(options) : getClient();\n  return client.connect<T>(service);\n}\n\n// ============================================================================\n// Re-exports from rpc.do\n// ============================================================================\n\nexport { RpcClient } from 'rpc.do';\n\nexport type {\n  TransportState,\n  ConnectionOptions,\n  ConnectionStats,\n} from '@dotdo/capnweb';\n\n// Error types re-exported from rpc.do (which re-exports from @dotdo/capnweb)\n// This ensures a single source of truth for error classes\nexport {\n  CapnwebError,\n  ConnectionError,\n  RpcError,\n  CapabilityError,\n  TimeoutError,\n  SerializationError,\n  // Error codes and utilities\n  ErrorCode,\n  ErrorCodeName,\n  isErrorCode,\n  createError,\n  wrapError,\n} from 'rpc.do';\nexport type { ErrorCodeType } from 'rpc.do';\n\n// ============================================================================\n// Pool-specific Error Types\n// ============================================================================\n\n/**\n * Pool-specific error code (extends the base error code ranges)\n * Uses 6xxx range for pool-related errors\n */\nexport const PoolErrorCode = {\n  /** Pool acquisition timeout */\n  POOL_TIMEOUT_ERROR: 6001,\n} as const;\n\nexport type PoolErrorCodeType = (typeof PoolErrorCode)[keyof typeof PoolErrorCode];\n\n/**\n * Error thrown when acquiring a connection from the pool times out\n *\n * Error Code: 6001 (POOL_TIMEOUT_ERROR)\n */\nexport class PoolTimeoutError extends CapnwebError {\n  constructor(\n    message: string,\n    public readonly url: string,\n    public readonly timeout: number\n  ) {\n    // Use type assertion since we're extending the error code range\n    super(message, PoolErrorCode.POOL_TIMEOUT_ERROR as any, 'POOL_TIMEOUT_ERROR');\n    this.name = 'PoolTimeoutError';\n    // Ensure proper prototype chain for instanceof checks\n    Object.setPrototypeOf(this, PoolTimeoutError.prototype);\n  }\n}\n\n// ============================================================================\n// Test Support\n// ============================================================================\n\n/**\n * Test server configuration for SDK conformance testing\n */\nexport interface TestServerConfig {\n  /** Port to listen on (0 for ephemeral) */\n  port?: number;\n  /** API key requirement */\n  apiKey?: string;\n  /** Enable verbose logging */\n  verbose?: boolean;\n  /** Custom TestTarget implementation */\n  target?: unknown;\n}\n\n/**\n * Test server instance returned by createTestServer\n */\nexport interface TestServerInstance {\n  /** HTTP URL for batch RPC */\n  url: string;\n  /** WebSocket URL for streaming RPC */\n  wsUrl: string;\n  /** DotDo client connected to this server */\n  client: DotDo;\n  /** Shutdown the server */\n  shutdown: () => Promise<void>;\n  /** Server port */\n  port: number;\n}\n\n/**\n * Create a test server for SDK conformance testing.\n *\n * This function is designed for use in test frameworks to spin up\n * a dotdo-backed test server for running conformance tests.\n *\n * @param config - Server configuration\n * @returns Test server instance\n *\n * @example\n * ```ts\n * import { createTestServer } from 'platform.do';\n *\n * // In test setup\n * const server = await createTestServer({ verbose: true });\n *\n * // Connect SDK to test server\n * const client = await server.client.connect('test');\n *\n * // Run tests...\n *\n * // In test teardown\n * await server.shutdown();\n * ```\n */\nexport async function createTestServer(_config: TestServerConfig = {}): Promise<TestServerInstance> {\n  // TODO: Implement test server setup when test infrastructure is available\n  throw new Error('createTestServer not yet implemented - test server infrastructure pending');\n}\n\n/**\n * Test client options for connecting to a test server\n */\nexport interface TestClientOptions extends DotDoOptions {\n  /** Test server URL */\n  serverUrl: string;\n}\n\n/**\n * Create a DotDo client configured for testing.\n *\n * @param options - Test client options\n * @returns Configured DotDo client\n *\n * @example\n * ```ts\n * import { createTestClient } from 'platform.do';\n *\n * const client = createTestClient({\n *   serverUrl: 'http://localhost:8787',\n *   debug: true,\n * });\n *\n * const api = await client.connect('test');\n * ```\n */\nexport function createTestClient(options: TestClientOptions): DotDo {\n  return new DotDo({\n    ...options,\n    baseUrl: options.serverUrl,\n  });\n}\n"]}