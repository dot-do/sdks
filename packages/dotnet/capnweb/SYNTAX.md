# Cap'n Web C# Client Syntax Exploration

This document explores divergent syntactic approaches for a modern C# client library (`CapnWeb` on NuGet) implementing the Cap'n Web RPC protocol.

## Background

Cap'n Web is a bidirectional capability-based RPC protocol over JSON with these core concepts:

- **Stubs**: Proxy objects where method calls forward to remote servers
- **Pipelining**: Chaining calls without awaiting intermediate results
- **Targets**: Local objects exposed for remote invocation
- **Sessions**: WebSocket and HTTP batch transports

## Design Goals

A modern C# developer should say: "This is elegant, idiomatic C#." That means:

1. First-class async/await support
2. Nullable reference types throughout
3. IAsyncDisposable for session management
4. Strong typing with generics
5. Natural LINQ-style composition
6. Source generators where beneficial

---

## Approach 1: DynamicObject with Fluent Pipelining

**Philosophy**: Minimal ceremony, maximum flexibility. Use C#'s `dynamic` for ultimate expressiveness.

### Session Creation

```csharp
// WebSocket session with IAsyncDisposable
await using var session = await CapnWeb.ConnectAsync("wss://api.example.com");
dynamic api = session.Api;

// Or with explicit type hints for IDE support
await using var session = await CapnWeb.ConnectAsync<IMyApi>("wss://api.example.com");
IMyApi api = session.Api;

// HTTP batch mode
await using var batch = CapnWeb.CreateBatch<IMyApi>("https://api.example.com/rpc");
```

### Making RPC Calls

```csharp
// Simple call
string greeting = await api.Greet("World");

// With dynamic, everything just works
dynamic user = await api.GetUser(123);
string name = await user.Profile.Name;
```

### Pipelining Syntax

```csharp
// Fluent pipelining - calls don't execute until awaited
var authedApi = api.Authenticate(token);  // Returns RpcPromise<IAuthedApi>
var userId = authedApi.GetUserId();        // Pipelined, no await
var profile = api.GetUserProfile(userId);  // Uses userId promise directly

// Execute the pipeline
var result = await profile;

// Or with explicit Pipeline builder
var profile = await Pipeline.From(api)
    .Call(a => a.Authenticate(token))
    .Then(auth => auth.GetUserId())
    .Then(id => api.GetUserProfile(id))
    .ExecuteAsync();
```

### LINQ-Style Map for Collections

```csharp
// Remote .map() - transforms data without pulling it locally
var friendIds = authedApi.GetFriendIds();  // RpcPromise<int[]>
var profiles = await friendIds.Map(id => api.GetUserProfile(id));

// With LINQ syntax (via extension methods)
var profiles = await (
    from id in authedApi.GetFriendIds()
    select api.GetUserProfile(id)
);
```

### Error Handling

```csharp
// Traditional try/catch
try
{
    var user = await api.GetUser(invalidId);
}
catch (RpcException ex) when (ex.ErrorType == "NotFound")
{
    Console.WriteLine($"User not found: {ex.Message}");
}

// Session-level error handling
session.OnError += (sender, ex) => Log.Error(ex);
```

### Exposing Local Objects as Targets

```csharp
// Inherit from RpcTarget
public class MyApiServer : RpcTarget
{
    public string Greet(string name) => $"Hello, {name}!";

    public async Task<UserProfile> GetUserProfileAsync(int userId)
    {
        return await _db.GetProfileAsync(userId);
    }
}

// Or use attribute-based discovery
public class MyApiServer
{
    [RpcMethod]
    public string Greet(string name) => $"Hello, {name}!";

    [RpcMethod("getUserProfile")]  // Custom name
    public Task<UserProfile> GetProfileAsync(int userId) => /* ... */;
}

// Server setup
await using var session = CapnWeb.Accept(webSocket, new MyApiServer());
```

### Disposal and Lifecycle

```csharp
// Automatic with `await using`
await using var api = await CapnWeb.ConnectAsync<IMyApi>(url);
await using var authedApi = await api.Authenticate(token);
// authedApi.Dispose() releases the remote reference

// Manual reference management
var stub = api.GetResource();
try
{
    await stub.DoWork();
}
finally
{
    await stub.DisposeAsync();  // Release remote reference
}
```

---

## Approach 2: Source-Generated Typed Stubs

**Philosophy**: Maximum type safety. Use source generators to create strongly-typed stubs at compile time.

### Interface Definition

```csharp
// Define your RPC interface
[RpcInterface]
public partial interface IMyApi
{
    Task<string> GreetAsync(string name);

    [RpcPipeline]  // Marks return value as pipelineable
    IAuthedApi Authenticate(string token);

    Task<UserProfile> GetUserProfileAsync(int userId);
}

[RpcInterface]
public partial interface IAuthedApi
{
    Task<int> GetUserIdAsync();
    Task<int[]> GetFriendIdsAsync();
}
```

### Generated Code (simplified)

```csharp
// Auto-generated by CapnWeb.Generators
public partial interface IMyApi
{
    // Source generator adds:
    // - RpcPromise<T> overloads for pipelining
    // - Extension methods for Map
    // - Disposal tracking
}

public sealed class MyApiStub : IMyApi, IAsyncDisposable
{
    private readonly RpcSession _session;
    private readonly ImportId _importId;

    public RpcPromise<string> Greet(string name)
        => _session.Call<string>(_importId, "greet", name);

    // Explicit interface implementation for await
    async Task<string> IMyApi.GreetAsync(string name)
        => await Greet(name);
}
```

### Session Creation

```csharp
// Type-safe connection
await using var session = await CapnWeb.ConnectAsync<IMyApi>("wss://api.example.com");
IMyApi api = session.Stub;

// Alternative: builder pattern
await using var session = await new CapnWebSessionBuilder()
    .WithEndpoint("wss://api.example.com")
    .WithInterface<IMyApi>()
    .WithTimeout(TimeSpan.FromSeconds(30))
    .WithReconnect(maxRetries: 3)
    .BuildAsync();
```

### Pipelining Syntax

```csharp
// Generated stubs return RpcPromise<T> for seamless pipelining
RpcPromise<IAuthedApi> authedApi = api.Authenticate(token);
RpcPromise<int> userId = authedApi.GetUserId();  // Chains automatically
RpcPromise<UserProfile> profile = api.GetUserProfile(userId);

// Single await executes entire pipeline in one round-trip
UserProfile result = await profile;

// Explicit batching for HTTP mode
await using var batch = api.BeginBatch();
var greeting1 = batch.Greet("Alice");
var greeting2 = batch.Greet("Bob");
var (g1, g2) = await batch.ExecuteAsync(greeting1, greeting2);
```

### Map with Expression Trees

```csharp
// Type-safe Map using expression trees
RpcPromise<int[]> friendIds = authedApi.GetFriendIds();

// The lambda is analyzed at compile time, serialized as instructions
var friendProfiles = await friendIds.MapAsync(id => new
{
    Id = id,
    Profile = api.GetUserProfile(id)
});

// Generates efficient wire format automatically
```

### Error Handling with Result<T>

```csharp
// Optional Result<T> pattern (no exceptions)
Result<UserProfile> result = await api.GetUserProfile(userId).AsResult();

if (result.IsSuccess)
{
    Console.WriteLine(result.Value.Name);
}
else
{
    Console.WriteLine($"Error: {result.Error.Message}");
}

// Or use pattern matching
var message = await api.GetUserProfile(userId).AsResult() switch
{
    { IsSuccess: true, Value: var profile } => $"Hello, {profile.Name}!",
    { Error: RpcError { Type: "NotFound" } } => "User not found",
    { Error: var e } => $"Error: {e.Message}"
};

// OneOf-style discriminated union
var result = await api.GetUserProfile(userId).ToUnion<UserProfile, NotFoundError, AuthError>();
result.Switch(
    profile => HandleProfile(profile),
    notFound => HandleNotFound(),
    authError => HandleAuthError()
);
```

### Exposing Local Objects

```csharp
// Implement the generated interface
public class MyApiServer : IMyApi, IRpcTarget
{
    public Task<string> GreetAsync(string name)
        => Task.FromResult($"Hello, {name}!");

    public IAuthedApi Authenticate(string token)
    {
        var user = ValidateToken(token);
        return new AuthedApiServer(user);  // Returns another RpcTarget
    }

    public async Task<UserProfile> GetUserProfileAsync(int userId)
        => await _db.GetProfileAsync(userId);
}

// Automatic disposal notification via interface
public class ResourceServer : IRpcTarget, IAsyncDisposable
{
    public async ValueTask DisposeAsync()
    {
        // Called when remote stub is released
        await _resource.CloseAsync();
    }
}
```

---

## Approach 3: LINQ Query Syntax with Monadic Composition

**Philosophy**: Treat RPC calls as composable effects. Leverage LINQ's query syntax for elegant pipelining.

### Core Abstractions

```csharp
// RpcCall<T> is a monadic container representing a remote call
public readonly struct RpcCall<T>
{
    // Supports LINQ operators: Select, SelectMany, Where
    public RpcCall<TResult> Select<TResult>(Func<T, TResult> selector);
    public RpcCall<TResult> SelectMany<TResult>(Func<T, RpcCall<TResult>> selector);
}

// RpcBatch collects calls for execution
public sealed class RpcBatch : IAsyncEnumerable<object?>
{
    public RpcCall<T> Add<T>(RpcCall<T> call);
    public Task<T[]> ExecuteAsync<T>(params RpcCall<T>[] calls);
}
```

### LINQ Query Syntax for Pipelining

```csharp
await using var api = await CapnWeb.ConnectAsync<IMyApi>(url);

// Beautiful query syntax for complex pipelines
var friendProfiles =
    from auth in api.Authenticate(token)
    from userId in auth.GetUserId()
    from friendIds in auth.GetFriendIds()
    from profile in api.GetUserProfile(userId)
    select new { UserId = userId, Profile = profile, FriendCount = friendIds.Length };

// All of this executes in a single round-trip!
var result = await friendProfiles;
```

### Parallel Composition

```csharp
// Combine multiple independent calls
var combined =
    from greeting in api.Greet("World")
    from time in api.GetServerTime()
    from stats in api.GetStats()
    select (greeting, time, stats);

var (greeting, time, stats) = await combined;

// Or using applicative style
var result = await (
    api.Greet("World"),
    api.GetServerTime(),
    api.GetStats()
).Zip((g, t, s) => new { Greeting = g, Time = t, Stats = s });
```

### Map with Query Comprehensions

```csharp
// Flat and nested transformations
var friendDetails =
    from friendId in api.GetFriendIds()     // RpcCall<int[]>
    from profile in friendId.AsCall()        // Lift each int into the monad
        .SelectMany(id => api.GetProfile(id))
    select new FriendDetail(friendId, profile);

// Equivalent fluent syntax
var friendDetails = api.GetFriendIds()
    .SelectMany(ids => ids.Traverse(id => api.GetProfile(id)))
    .Select(profiles => profiles.ToArray());
```

### Error Handling with Railway-Oriented Style

```csharp
// RpcCall<T> can be combined with Result<T>
var safeResult =
    from auth in api.Authenticate(token).Catch()      // RpcCall<Result<IAuthedApi>>
    from user in auth.Bind(a => a.GetUser().Catch())  // Chain Results
    select user;

// Execute and handle errors uniformly
var result = await safeResult;
result.Match(
    success: user => Console.WriteLine(user.Name),
    failure: error => Console.WriteLine($"Failed: {error}")
);

// Or define error recovery inline
var resilientCall = api.GetUser(id)
    .Catch()
    .OrElse(() => api.GetDefaultUser())
    .OrElse(() => RpcCall.Return(User.Anonymous));
```

### Session and Target Definition

```csharp
// Functional target definition with expression handlers
var server = RpcTarget.Create(handlers => handlers
    .On<string, string>("greet", name => $"Hello, {name}!")
    .On<int, UserProfile>("getUserProfile", async id => await _db.GetAsync(id))
    .On("authenticate", (string token) =>
    {
        var user = ValidateToken(token);
        return RpcTarget.Create(h => h
            .On<int>("getUserId", () => user.Id)
            .On<int[]>("getFriendIds", () => user.FriendIds)
        );
    })
);

await using var session = CapnWeb.Accept(webSocket, server);
```

---

## Approach 4: Record-Based API with Pattern Matching

**Philosophy**: Embrace modern C# records and pattern matching for a data-centric approach.

### Request/Response Records

```csharp
// Define calls as records
public record GreetRequest(string Name);
public record GreetResponse(string Message);

public record GetUserRequest(int UserId);
public record AuthenticateRequest(string Token);

// Response wrapper with discriminated union
public abstract record RpcResponse<T>
{
    public record Success(T Value) : RpcResponse<T>;
    public record Error(string Type, string Message, string? Stack = null) : RpcResponse<T>;
}
```

### Making Calls with Records

```csharp
await using var rpc = await CapnWeb.ConnectAsync(url);

// Type-inferred call dispatch
var response = await rpc.CallAsync(new GreetRequest("World"));
// Returns RpcResponse<GreetResponse>

// Pattern match the response
var message = response switch
{
    RpcResponse<GreetResponse>.Success(var r) => r.Message,
    RpcResponse<GreetResponse>.Error(var type, var msg, _) => $"Error [{type}]: {msg}",
    _ => throw new InvalidOperationException()
};
```

### Pipelining with Pipeline Records

```csharp
// Define a pipeline as a composition of operations
var pipeline = new RpcPipeline()
    .Then(new AuthenticateRequest(token))
    .Then(auth => new GetUserIdRequest())
    .Then(userId => new GetProfileRequest(userId))
    .Then(profile => new GetFriendsRequest(profile.Id));

// Execute entire pipeline
var friends = await rpc.ExecuteAsync(pipeline);

// Or build pipelines with records
public record PipelinedCall<TIn, TOut>(
    RpcPipeline<TIn> Previous,
    Func<TIn, object> CreateRequest
) : RpcPipeline<TOut>;

// Fluent builder
var result = await RpcPipeline
    .Start(new AuthenticateRequest(token))
    .Select(auth => new GetUserIdRequest())
    .Select(id => new GetProfileRequest(id))
    .ExecuteOn(rpc);
```

### Advanced Pattern Matching for Results

```csharp
// Rich pattern matching with guards
var action = await rpc.CallAsync(new GetUserRequest(userId)) switch
{
    RpcResponse<User>.Success({ IsActive: true } user)
        => ActivateUser(user),

    RpcResponse<User>.Success({ IsActive: false } user)
        => ShowInactiveMessage(user),

    RpcResponse<User>.Error("NotFound", _, _)
        => ShowNotFound(),

    RpcResponse<User>.Error("Unauthorized", _, _)
        => RedirectToLogin(),

    RpcResponse<User>.Error(var type, var msg, var stack)
        => LogAndShowError(type, msg, stack),
};
```

### Session as Record with Deconstruction

```csharp
// Session provides multiple capabilities via deconstruction
await using var (api, events, admin) = await CapnWeb
    .ConnectAsync<IApi, IEvents, IAdmin>(url);

// Use independently
await api.GreetAsync("World");
await foreach (var evt in events.StreamAsync())
{
    Console.WriteLine(evt);
}

// Record-based configuration
var options = new CapnWebOptions
{
    Endpoint = "wss://api.example.com",
    Timeout = TimeSpan.FromSeconds(30),
    ReconnectPolicy = new ExponentialBackoff(MaxRetries: 5),
    Serializer = new SystemTextJsonSerializer(),
    CancellationToken = cts.Token
};

await using var session = await CapnWeb.ConnectAsync<IApi>(options);
```

### Target Implementation with Records

```csharp
// Define a target with record-based dispatch
public class ApiServer : IRpcDispatcher
{
    public async ValueTask<object?> DispatchAsync(RpcRequest request)
    {
        return request switch
        {
            RpcRequest<GreetRequest> { Payload: var req }
                => new GreetResponse($"Hello, {req.Name}!"),

            RpcRequest<GetUserRequest> { Payload: var req }
                => await _db.GetUserAsync(req.UserId),

            RpcRequest<AuthenticateRequest> { Payload: var req }
                => CreateAuthenticatedApi(ValidateToken(req.Token)),

            _ => throw new RpcMethodNotFoundException(request.Method)
        };
    }
}

// Or with automatic dispatch via source generation
[RpcTarget]
public partial class ApiServer
{
    public GreetResponse Handle(GreetRequest request)
        => new($"Hello, {request.Name}!");

    public async Task<User> Handle(GetUserRequest request)
        => await _db.GetUserAsync(request.UserId);
}
```

---

## Comparison Matrix

| Feature | Approach 1: Dynamic | Approach 2: Source Gen | Approach 3: LINQ | Approach 4: Records |
|---------|---------------------|------------------------|------------------|---------------------|
| Type Safety | Low (runtime) | High (compile-time) | Medium | High |
| IDE Support | Limited | Excellent | Good | Excellent |
| Learning Curve | Low | Medium | High | Medium |
| Boilerplate | Minimal | Low (generated) | Minimal | Medium |
| Pipelining | Fluent | Generated | Query syntax | Builder |
| Error Handling | Exceptions | Result<T> | Railway | Pattern matching |
| AOT Compatible | No | Yes | Partial | Yes |
| Debuggability | Challenging | Excellent | Good | Excellent |

---

## Recommended Hybrid Approach

The best library would combine strengths from multiple approaches:

```csharp
// Source-generated interfaces for type safety (Approach 2)
[RpcInterface]
public partial interface IMyApi
{
    Task<string> GreetAsync(string name);
    IAuthedApi Authenticate(string token);
}

// LINQ operators for elegant pipelining (Approach 3)
var result =
    from auth in api.Authenticate(token)
    from profile in api.GetProfile(auth.UserId)
    select profile;

// Result<T> with pattern matching for errors (Approach 4)
var response = await api.GetUser(id).AsResult();
var message = response switch
{
    { IsSuccess: true, Value: var user } => user.Name,
    { Error.Type: "NotFound" } => "Unknown",
    { Error: var e } => throw new RpcException(e)
};

// Dynamic fallback for prototyping (Approach 1)
dynamic flexibleApi = session.Dynamic;
await flexibleApi.SomeNewMethod(arg1, arg2);
```

### Implementation Priorities

1. **Core Protocol**: Implement serialization, import/export tables, transports
2. **RpcPromise<T>**: The key abstraction enabling pipelining
3. **Source Generators**: For typed stubs and targets
4. **LINQ Extensions**: `Select`, `SelectMany`, `Map` for composition
5. **Result<T>**: Optional error handling without exceptions
6. **Dynamic Fallback**: For exploratory development

---

## Technical Notes

### Nullable Reference Types

All public APIs should use nullable reference types:

```csharp
public interface IRpcSession
{
    Task<T> CallAsync<T>(string method, params object?[] args);
    Task<T?> TryCallAsync<T>(string method, params object?[] args) where T : class;
}
```

### Cancellation

All async operations support `CancellationToken`:

```csharp
public interface IRpcSession
{
    Task<T> CallAsync<T>(
        string method,
        object?[] args,
        CancellationToken cancellationToken = default);
}
```

### IAsyncDisposable Everywhere

```csharp
public interface IRpcSession : IAsyncDisposable
{
    // Session resources
}

public interface IRpcStub<T> : IAsyncDisposable
{
    // Remote reference
}

public interface IRpcPromise<T> : IAsyncDisposable
{
    // Pipelined operation
}
```

### AOT Considerations

For Native AOT compatibility:
- Avoid reflection where possible
- Use source generators instead of `DynamicObject`
- Provide explicit JSON serialization contracts

```csharp
[JsonSerializable(typeof(RpcMessage))]
[JsonSerializable(typeof(RpcExpression))]
public partial class CapnWebJsonContext : JsonSerializerContext { }
```

---

## Next Steps

1. Prototype each approach with a minimal implementation
2. Gather feedback from C# developers
3. Benchmark pipelining performance
4. Finalize API design
5. Implement source generators
6. Write comprehensive tests
7. Publish to NuGet as `CapnWeb`
